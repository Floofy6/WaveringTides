{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useInventory } from './useInventory';\nimport { SKILL_IDS, ENEMIES, ITEM_IDS, ITEMS } from '../constants';\n\n/**\n * useCombat hook - Manages combat-related state and operations\n */\nexport const useCombat = () => {\n  _s();\n  const {\n    gameState,\n    updateGameState\n  } = useGameContext();\n  const {\n    addItem\n  } = useInventory();\n\n  // Use enemies from constants rather than mock data\n  const [enemies] = useState(Object.values(ENEMIES));\n\n  // Local state for combat\n  const [currentEnemy, setCurrentEnemy] = useState(null);\n  const [combatLog, setCombatLog] = useState([]);\n  const [combatInterval, setCombatInterval] = useState(null);\n  const [combatTick, setCombatTick] = useState(0); // Used to trigger combat animations\n\n  // Track separate timers for player and enemy attacks\n  const [lastPlayerAttack, setLastPlayerAttack] = useState(0);\n  const [lastEnemyAttack, setLastEnemyAttack] = useState(0);\n  const [playerAttackTimer, setPlayerAttackTimer] = useState(null);\n  const [enemyAttackTimer, setEnemyAttackTimer] = useState(null);\n\n  // Compute player stats from the game state\n  const getPlayerStats = useCallback(() => {\n    var _gameState$player$ski, _gameState$player$ski2, _gameState$player$ski3, _gameState$player$ski4, _gameState$player$ski5, _gameState$player$equ, _gameState$player$equ2, _gameState$player$equ3, _gameState$player$equ4, _gameState$player$equ5, _gameState$player$equ6;\n    if (!(gameState !== null && gameState !== void 0 && gameState.player)) return {\n      attack: 1,\n      strength: 1,\n      defense: 1,\n      health: 10,\n      maxHealth: 10\n    };\n    const attack = ((_gameState$player$ski = gameState.player.skills[SKILL_IDS.ATTACK]) === null || _gameState$player$ski === void 0 ? void 0 : _gameState$player$ski.level) || 1;\n    const strength = ((_gameState$player$ski2 = gameState.player.skills[SKILL_IDS.STRENGTH]) === null || _gameState$player$ski2 === void 0 ? void 0 : _gameState$player$ski2.level) || 1;\n    const defense = ((_gameState$player$ski3 = gameState.player.skills[SKILL_IDS.DEFENCE]) === null || _gameState$player$ski3 === void 0 ? void 0 : _gameState$player$ski3.level) || 1;\n\n    // Health is stored as XP in hitpoints skill\n    // If not defined or <= 0, default to 10 (minimum health)\n    const health = Math.max(10, ((_gameState$player$ski4 = gameState.player.skills[SKILL_IDS.HITPOINTS]) === null || _gameState$player$ski4 === void 0 ? void 0 : _gameState$player$ski4.xp) || 10);\n\n    // Max health calculation: 10 base + 4 per hitpoints level\n    const hitpointsLevel = ((_gameState$player$ski5 = gameState.player.skills[SKILL_IDS.HITPOINTS]) === null || _gameState$player$ski5 === void 0 ? void 0 : _gameState$player$ski5.level) || 1;\n    const maxHealth = 10 + hitpointsLevel * 4;\n\n    // Add equipment bonuses\n    const attackBonus = ((_gameState$player$equ = gameState.player.equipment.weapon) === null || _gameState$player$equ === void 0 ? void 0 : (_gameState$player$equ2 = _gameState$player$equ.stats) === null || _gameState$player$equ2 === void 0 ? void 0 : _gameState$player$equ2.attackBonus) || 0;\n    const strengthBonus = ((_gameState$player$equ3 = gameState.player.equipment.weapon) === null || _gameState$player$equ3 === void 0 ? void 0 : (_gameState$player$equ4 = _gameState$player$equ3.stats) === null || _gameState$player$equ4 === void 0 ? void 0 : _gameState$player$equ4.strengthBonus) || 0;\n    const defenseBonus = ((_gameState$player$equ5 = gameState.player.equipment.armor) === null || _gameState$player$equ5 === void 0 ? void 0 : (_gameState$player$equ6 = _gameState$player$equ5.stats) === null || _gameState$player$equ6 === void 0 ? void 0 : _gameState$player$equ6.defenseBonus) || 0;\n    return {\n      attack: attack + attackBonus,\n      strength: strength + strengthBonus,\n      defense: defense + defenseBonus,\n      health,\n      maxHealth\n    };\n  }, [gameState]);\n\n  // Calculate combat stats\n  const playerStats = getPlayerStats();\n\n  /**\n   * Add a message to the combat log\n   */\n  const addLogMessage = useCallback(message => {\n    setCombatLog(prevLog => [message, ...prevLog].slice(0, 50)); // Keep last 50 messages\n  }, []);\n\n  /**\n   * Calculate damage based on attacker and defender stats\n   * Improved formula for more balanced combat\n   */\n  const calculateDamage = useCallback((attackerAttack, attackerStrength, defenderDefense) => {\n    try {\n      // Calculate hit chance - improved formula\n      // Higher attack vs defense = better chance to hit\n      const effectiveAttack = attackerAttack + 10; // Increased base value for better early game hit chance\n      const hitChance = Math.min(0.95, Math.max(0.2, effectiveAttack / (effectiveAttack + defenderDefense * 0.7)));\n      const didHit = Math.random() < hitChance;\n      if (!didHit) return 0;\n\n      // Base damage calculation - improved for more consistent damage\n      // Higher strength = higher potential damage\n      const maxHit = Math.floor(1 + attackerStrength * 0.15); // Increased base damage multiplier\n      const damageVariation = 0.7; // 70% variation to make damage more consistent\n      const minDamage = Math.max(1, Math.floor(maxHit * (1 - damageVariation)));\n      const damage = Math.floor(minDamage + Math.random() * (maxHit - minDamage + 1));\n      return Math.max(1, damage); // Always hit at least 1 if the attack lands\n    } catch (error) {\n      console.error('Error calculating damage:', error);\n      return 1; // Fallback to minimum damage on error\n    }\n  }, []);\n\n  /**\n   * Calculate XP required for next level using OSRS-inspired formula\n   */\n  const calculateXpForNextLevel = useCallback(level => {\n    return Math.floor(100 * level ** 1.5);\n  }, []);\n\n  /**\n   * Handle enemy defeat and loot\n   */\n  const handleEnemyDefeated = useCallback(enemy => {\n    console.log(\"Handling enemy defeat:\", enemy.name);\n\n    // Stop combat loop\n    if (combatInterval) {\n      console.log(\"Clearing combat interval\");\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n\n    // Stop attack timers\n    if (playerAttackTimer) {\n      console.log(\"Clearing player attack timer\");\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    if (enemyAttackTimer) {\n      console.log(\"Clearing enemy attack timer\");\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n    addLogMessage(`You defeated the ${enemy.name}!`);\n\n    // Process loot drops\n    const lootMessages = [];\n    const lootItems = [];\n    enemy.lootTable.forEach(loot => {\n      if (Math.random() <= loot.chance) {\n        var _ITEMS$loot$itemId, _ITEMS$loot$itemId2, _ITEMS$loot$itemId3, _ITEMS$loot$itemId4;\n        lootMessages.push(`You received ${loot.quantity} ${loot.itemId}!`);\n\n        // Use the item constants directly\n        const itemName = ((_ITEMS$loot$itemId = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId === void 0 ? void 0 : _ITEMS$loot$itemId.name) || loot.itemId;\n        lootItems.push({\n          id: loot.itemId,\n          name: itemName,\n          quantity: loot.quantity,\n          type: ((_ITEMS$loot$itemId2 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId2 === void 0 ? void 0 : _ITEMS$loot$itemId2.type) || 'resource',\n          sellPrice: ((_ITEMS$loot$itemId3 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId3 === void 0 ? void 0 : _ITEMS$loot$itemId3.sellPrice) || 5,\n          stats: (_ITEMS$loot$itemId4 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId4 === void 0 ? void 0 : _ITEMS$loot$itemId4.stats\n        });\n      }\n    });\n\n    // Award gold\n    const goldAmount = Math.floor(Math.random() * (enemy.maxHealth / 2)) + 5;\n    lootMessages.push(`You found ${goldAmount} gold!`);\n\n    // Update player state with loot and gold\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      const newState = JSON.parse(JSON.stringify(prevState));\n\n      // Add gold\n      newState.player.gold += goldAmount;\n\n      // Add items to inventory - directly update inventory in the state\n      lootItems.forEach(item => {\n        if (newState.player.inventory[item.id]) {\n          newState.player.inventory[item.id].quantity += item.quantity;\n        } else {\n          newState.player.inventory[item.id] = item;\n        }\n      });\n\n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      return newState;\n    });\n\n    // Display loot messages\n    lootMessages.forEach(msg => addLogMessage(msg));\n\n    // Reset current enemy\n    console.log(\"Resetting current enemy to null\");\n    setCurrentEnemy(null);\n  }, [combatInterval, playerAttackTimer, enemyAttackTimer, addLogMessage, updateGameState]);\n\n  /**\n   * Handle player defeat\n   */\n  const handlePlayerDefeated = useCallback(() => {\n    console.log(\"Handling player defeat\");\n\n    // Stop combat loop\n    if (combatInterval) {\n      console.log(\"Clearing combat interval\");\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n\n    // Stop attack timers\n    if (playerAttackTimer) {\n      console.log(\"Clearing player attack timer\");\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    if (enemyAttackTimer) {\n      console.log(\"Clearing enemy attack timer\");\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n    addLogMessage('You have been defeated!');\n\n    // Update player state - reset combat and restore some health\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      const newState = JSON.parse(JSON.stringify(prevState));\n\n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n\n      // Restore some hitpoints - 25% of max health\n      if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n        const hitpointsLevel = newState.player.skills[SKILL_IDS.HITPOINTS].level || 1;\n        const maxHealth = 10 + hitpointsLevel * 4;\n        newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.floor(maxHealth * 0.25);\n        addLogMessage('You wake up with some health restored.');\n      }\n      return newState;\n    });\n\n    // Reset current enemy\n    console.log(\"Resetting current enemy to null\");\n    setCurrentEnemy(null);\n  }, [combatInterval, playerAttackTimer, enemyAttackTimer, addLogMessage, updateGameState]);\n\n  /**\n   * Calculate player's attack speed in milliseconds\n   * Lower numbers mean faster attacks\n   */\n  const getPlayerAttackSpeed = useCallback(() => {\n    var _gameState$player, _gameState$player$equ7, _gameState$player2, _gameState$player2$sk;\n    // Base attack speed\n    let attackSpeed = 2000; // Base: 2 seconds between attacks\n\n    // Factor in weapon type\n    if (gameState !== null && gameState !== void 0 && (_gameState$player = gameState.player) !== null && _gameState$player !== void 0 && (_gameState$player$equ7 = _gameState$player.equipment) !== null && _gameState$player$equ7 !== void 0 && _gameState$player$equ7.weapon) {\n      var _weapon$stats;\n      const weapon = gameState.player.equipment.weapon;\n      console.log(\"Player weapon found:\", weapon.name);\n\n      // Different weapons have different speeds\n      if (weapon.id === ITEM_IDS.BRONZE_SWORD) {\n        attackSpeed = 1800; // Swords are faster\n        console.log(\"Sword equipped - base speed is now 1800ms\");\n      }\n\n      // Weapon quality can further improve speed\n      if ((_weapon$stats = weapon.stats) !== null && _weapon$stats !== void 0 && _weapon$stats.attackBonus) {\n        // Each point of attack bonus reduces attack time by 50ms\n        const reduction = weapon.stats.attackBonus * 50;\n        attackSpeed -= reduction;\n        console.log(`Weapon bonus reduces attack time by ${reduction}ms`);\n      }\n    }\n\n    // Factor in skills - higher attack level = faster attacks\n    const attackLevel = (gameState === null || gameState === void 0 ? void 0 : (_gameState$player2 = gameState.player) === null || _gameState$player2 === void 0 ? void 0 : (_gameState$player2$sk = _gameState$player2.skills[SKILL_IDS.ATTACK]) === null || _gameState$player2$sk === void 0 ? void 0 : _gameState$player2$sk.level) || 1;\n    // Each level above 1 reduces attack time by 20ms\n    const levelReduction = (attackLevel - 1) * 20;\n    attackSpeed -= levelReduction;\n    console.log(`Attack level ${attackLevel} reduces attack time by ${levelReduction}ms`);\n\n    // Ensure attack speed doesn't go below minimum (very fast)\n    const finalSpeed = Math.max(800, attackSpeed);\n    console.log(`Final player attack speed: ${finalSpeed}ms`);\n    return finalSpeed;\n  }, [gameState]);\n\n  /**\n   * Process player attack\n   */\n  const processPlayerAttack = useCallback(() => {\n    if (!currentEnemy || !(gameState !== null && gameState !== void 0 && gameState.player)) {\n      console.log(\"Cannot process player attack - missing enemy or player data\");\n      return;\n    }\n    console.log(\"Processing player attack against\", currentEnemy.name);\n\n    // Get current player stats\n    const stats = getPlayerStats();\n    console.log(\"Player stats:\", stats);\n\n    // Player attacks enemy\n    const playerDamage = calculateDamage(stats.attack, stats.strength, currentEnemy.defense);\n    console.log(\"Player damage calculated:\", playerDamage);\n    if (playerDamage > 0) {\n      // Update enemy health\n      const newEnemyHealth = Math.max(0, currentEnemy.health - playerDamage);\n      console.log(`Enemy health: ${currentEnemy.health} -> ${newEnemyHealth}`);\n      setCurrentEnemy(prev => {\n        if (!prev) return null;\n        const updated = {\n          ...prev,\n          health: newEnemyHealth\n        };\n        console.log(\"Updated enemy:\", updated);\n        return updated;\n      });\n\n      // Add attack message to combat log\n      addLogMessage(`You hit the ${currentEnemy.name} for ${playerDamage} damage!`);\n\n      // Trigger animation\n      setCombatTick(prev => prev + 1);\n\n      // Award combat XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        const newState = JSON.parse(JSON.stringify(prevState));\n\n        // Add XP to Attack and Strength\n        if (newState.player.skills[SKILL_IDS.ATTACK]) {\n          const attackXp = playerDamage * 4;\n          const currentAttackXp = newState.player.skills[SKILL_IDS.ATTACK].xp || 0;\n          newState.player.skills[SKILL_IDS.ATTACK].xp = currentAttackXp + attackXp;\n\n          // Check for level ups\n          const attackLevel = newState.player.skills[SKILL_IDS.ATTACK].level;\n          const xpForNextLevel = calculateXpForNextLevel(attackLevel);\n          if (newState.player.skills[SKILL_IDS.ATTACK].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.ATTACK].level += 1;\n            addLogMessage(`Congratulations! Your Attack level is now ${newState.player.skills[SKILL_IDS.ATTACK].level}`);\n          }\n        }\n        if (newState.player.skills[SKILL_IDS.STRENGTH]) {\n          const strengthXp = playerDamage * 4;\n          const currentStrengthXp = newState.player.skills[SKILL_IDS.STRENGTH].xp || 0;\n          newState.player.skills[SKILL_IDS.STRENGTH].xp = currentStrengthXp + strengthXp;\n\n          // Check for level ups\n          const strengthLevel = newState.player.skills[SKILL_IDS.STRENGTH].level;\n          const xpForNextLevel = calculateXpForNextLevel(strengthLevel);\n          if (newState.player.skills[SKILL_IDS.STRENGTH].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.STRENGTH].level += 1;\n            addLogMessage(`Congratulations! Your Strength level is now ${newState.player.skills[SKILL_IDS.STRENGTH].level}`);\n          }\n        }\n        return newState;\n      });\n\n      // Check if enemy is defeated\n      if (newEnemyHealth <= 0) {\n        console.log(\"Enemy defeated!\");\n        handleEnemyDefeated(currentEnemy);\n        return;\n      }\n    } else {\n      addLogMessage(`Your attack missed the ${currentEnemy.name}!`);\n      // Still trigger animation for the miss\n      setCombatTick(prev => prev + 1);\n    }\n\n    // Schedule next player attack\n    setLastPlayerAttack(Date.now());\n    console.log(\"Player attack completed, next attack scheduled\");\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handleEnemyDefeated]);\n\n  /**\n   * Process enemy attack\n   */\n  const processEnemyAttack = useCallback(() => {\n    if (!currentEnemy || !(gameState !== null && gameState !== void 0 && gameState.player)) {\n      console.log(\"Cannot process enemy attack - missing enemy or player data\");\n      return;\n    }\n    console.log(\"Processing enemy attack from\", currentEnemy.name);\n    const stats = getPlayerStats();\n    console.log(\"Player stats for defense:\", stats);\n\n    // Enemy attacks player\n    const enemyDamage = calculateDamage(currentEnemy.attack, currentEnemy.attack, stats.defense);\n    console.log(\"Enemy damage calculated:\", enemyDamage);\n    if (enemyDamage > 0) {\n      addLogMessage(`The ${currentEnemy.name} hits you for ${enemyDamage} damage!`);\n\n      // Trigger animation\n      setCombatTick(prev => prev + 2); // Use a different number to trigger a different animation\n\n      // Update player health and award Defense XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        const newState = JSON.parse(JSON.stringify(prevState));\n\n        // Add XP to Defense (positive XP for being hit)\n        if (newState.player.skills[SKILL_IDS.DEFENCE]) {\n          const defenseXp = enemyDamage * 4;\n          const currentDefenseXp = newState.player.skills[SKILL_IDS.DEFENCE].xp || 0;\n          newState.player.skills[SKILL_IDS.DEFENCE].xp = currentDefenseXp + defenseXp;\n\n          // Check for level ups\n          const defenseLevel = newState.player.skills[SKILL_IDS.DEFENCE].level;\n          const xpForNextLevel = calculateXpForNextLevel(defenseLevel);\n          if (newState.player.skills[SKILL_IDS.DEFENCE].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.DEFENCE].level += 1;\n            addLogMessage(`Congratulations! Your Defense level is now ${newState.player.skills[SKILL_IDS.DEFENCE].level}`);\n          }\n        }\n\n        // Reduce Hitpoints XP (as damage)\n        if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n          const currentHitpointsXp = newState.player.skills[SKILL_IDS.HITPOINTS].xp || 10;\n          const newHitpointsXp = Math.max(0, currentHitpointsXp - enemyDamage);\n          console.log(`Player health: ${currentHitpointsXp} -> ${newHitpointsXp}`);\n          newState.player.skills[SKILL_IDS.HITPOINTS].xp = newHitpointsXp;\n\n          // Check if player is defeated\n          if (newHitpointsXp <= 0) {\n            console.log(\"Player defeated!\");\n            handlePlayerDefeated();\n          }\n        }\n        return newState;\n      });\n    } else {\n      addLogMessage(`The ${currentEnemy.name}'s attack missed you!`);\n      // Still trigger animation for the miss\n      setCombatTick(prev => prev + 2);\n    }\n\n    // Schedule next enemy attack\n    setLastEnemyAttack(Date.now());\n    console.log(\"Enemy attack completed, next attack scheduled\");\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handlePlayerDefeated]);\n\n  /**\n   * Process a single combat round - now manages the timing for both player and enemy attacks\n   */\n  const processCombatRound = useCallback(() => {\n    if (!currentEnemy || !(gameState !== null && gameState !== void 0 && gameState.player)) {\n      console.log(\"Combat round skipped - no enemy or player\");\n      return;\n    }\n    const now = Date.now();\n    const playerSpeed = getPlayerAttackSpeed();\n    const enemySpeed = currentEnemy.attackSpeed || 2000; // Default to 2 seconds if not specified\n\n    // Check if it's time for player to attack\n    const timeSincePlayerAttack = now - lastPlayerAttack;\n    if (timeSincePlayerAttack >= playerSpeed) {\n      console.log(`Player attack triggered (${timeSincePlayerAttack}ms elapsed, speed: ${playerSpeed}ms)`);\n      processPlayerAttack();\n    }\n\n    // Check if it's time for enemy to attack\n    const timeSinceEnemyAttack = now - lastEnemyAttack;\n    if (timeSinceEnemyAttack >= enemySpeed) {\n      console.log(`Enemy attack triggered (${timeSinceEnemyAttack}ms elapsed, speed: ${enemySpeed}ms)`);\n      processEnemyAttack();\n    }\n  }, [currentEnemy, gameState, getPlayerAttackSpeed, lastPlayerAttack, lastEnemyAttack, processPlayerAttack, processEnemyAttack]);\n\n  /**\n   * Start combat with an enemy\n   */\n  const startCombat = useCallback(enemyId => {\n    console.log(\"Starting combat with enemy:\", enemyId);\n\n    // Stop any existing combat\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    if (playerAttackTimer) {\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    if (enemyAttackTimer) {\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n\n    // Find the enemy\n    const enemy = enemies.find(e => e.id === enemyId);\n    if (!enemy) {\n      console.error(`Enemy with ID ${enemyId} not found`);\n      return;\n    }\n\n    // Clone the enemy to avoid modifying the original\n    const enemyClone = {\n      ...enemy,\n      health: enemy.maxHealth,\n      // Reset health\n      attackSpeed: enemy.attackSpeed || 2000 // Ensure attackSpeed is set\n    };\n    console.log(\"Enemy clone created:\", enemyClone);\n    setCurrentEnemy(enemyClone);\n    setCombatLog([`Combat started with ${enemyClone.name}!`]);\n\n    // Reset attack timers\n    const now = Date.now();\n    setLastPlayerAttack(now);\n    setLastEnemyAttack(now);\n\n    // Update game state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            currentEnemy: enemyClone,\n            isFighting: true\n          }\n        }\n      };\n    });\n\n    // Process the first player attack immediately\n    console.log(\"Processing first player attack\");\n    processPlayerAttack();\n\n    // Set up the enemy's first attack with appropriate delay\n    console.log(\"Setting up enemy attack timer\");\n    const enemyDelay = enemyClone.attackSpeed / 2; // Half the enemy's speed for first attack\n    console.log(\"Enemy will attack in\", enemyDelay, \"ms\");\n    const enemyTimer = setTimeout(() => {\n      console.log(\"Processing enemy attack from timer\");\n      processEnemyAttack();\n    }, enemyDelay);\n    setEnemyAttackTimer(enemyTimer);\n\n    // Start combat loop - check for attacks every 100ms\n    console.log(\"Setting up combat interval\");\n    const interval = setInterval(() => {\n      console.log(\"Combat round check\");\n      processCombatRound();\n    }, 100);\n    setCombatInterval(interval);\n    return () => {\n      console.log(\"Cleaning up combat timers\");\n      clearInterval(interval);\n      clearTimeout(enemyTimer);\n    };\n  }, [enemies, combatInterval, playerAttackTimer, enemyAttackTimer, updateGameState, processCombatRound, processPlayerAttack, processEnemyAttack]);\n\n  /**\n   * Flee from combat\n   */\n  const fleeCombat = useCallback(() => {\n    if (!currentEnemy) return;\n\n    // Always succeed at fleeing\n    addLogMessage('You successfully fled from combat!');\n\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n\n    // Stop attack timers\n    if (playerAttackTimer) {\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    if (enemyAttackTimer) {\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n\n    // Update player state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            isFighting: false,\n            currentEnemy: undefined\n          }\n        }\n      };\n    });\n\n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [currentEnemy, combatInterval, playerAttackTimer, enemyAttackTimer, addLogMessage, updateGameState]);\n\n  // Clean up interval and timers on unmount\n  useEffect(() => {\n    return () => {\n      if (combatInterval) {\n        clearInterval(combatInterval);\n      }\n      if (playerAttackTimer) {\n        clearTimeout(playerAttackTimer);\n      }\n      if (enemyAttackTimer) {\n        clearTimeout(enemyAttackTimer);\n      }\n    };\n  }, [combatInterval, playerAttackTimer, enemyAttackTimer]);\n  return {\n    enemies,\n    currentEnemy,\n    isFighting: !!currentEnemy,\n    playerStats,\n    combatLog,\n    combatTick,\n    // Expose combat tick for animations\n    startCombat,\n    fleeCombat,\n    processCombatRound // Exposed for manual combat if needed\n  };\n};\n_s(useCombat, \"5Guo9otxv8630QhusW5aP5WK2zs=\", false, function () {\n  return [useGameContext, useInventory];\n});","map":{"version":3,"names":["useState","useCallback","useEffect","useGameContext","useInventory","SKILL_IDS","ENEMIES","ITEM_IDS","ITEMS","useCombat","_s","gameState","updateGameState","addItem","enemies","Object","values","currentEnemy","setCurrentEnemy","combatLog","setCombatLog","combatInterval","setCombatInterval","combatTick","setCombatTick","lastPlayerAttack","setLastPlayerAttack","lastEnemyAttack","setLastEnemyAttack","playerAttackTimer","setPlayerAttackTimer","enemyAttackTimer","setEnemyAttackTimer","getPlayerStats","_gameState$player$ski","_gameState$player$ski2","_gameState$player$ski3","_gameState$player$ski4","_gameState$player$ski5","_gameState$player$equ","_gameState$player$equ2","_gameState$player$equ3","_gameState$player$equ4","_gameState$player$equ5","_gameState$player$equ6","player","attack","strength","defense","health","maxHealth","skills","ATTACK","level","STRENGTH","DEFENCE","Math","max","HITPOINTS","xp","hitpointsLevel","attackBonus","equipment","weapon","stats","strengthBonus","defenseBonus","armor","playerStats","addLogMessage","message","prevLog","slice","calculateDamage","attackerAttack","attackerStrength","defenderDefense","effectiveAttack","hitChance","min","didHit","random","maxHit","floor","damageVariation","minDamage","damage","error","console","calculateXpForNextLevel","handleEnemyDefeated","enemy","log","name","clearInterval","clearTimeout","lootMessages","lootItems","lootTable","forEach","loot","chance","_ITEMS$loot$itemId","_ITEMS$loot$itemId2","_ITEMS$loot$itemId3","_ITEMS$loot$itemId4","push","quantity","itemId","itemName","id","type","sellPrice","goldAmount","prevState","newState","JSON","parse","stringify","gold","item","inventory","combat","isFighting","undefined","msg","handlePlayerDefeated","getPlayerAttackSpeed","_gameState$player","_gameState$player$equ7","_gameState$player2","_gameState$player2$sk","attackSpeed","_weapon$stats","BRONZE_SWORD","reduction","attackLevel","levelReduction","finalSpeed","processPlayerAttack","playerDamage","newEnemyHealth","prev","updated","attackXp","currentAttackXp","xpForNextLevel","strengthXp","currentStrengthXp","strengthLevel","Date","now","processEnemyAttack","enemyDamage","defenseXp","currentDefenseXp","defenseLevel","currentHitpointsXp","newHitpointsXp","processCombatRound","playerSpeed","enemySpeed","timeSincePlayerAttack","timeSinceEnemyAttack","startCombat","enemyId","find","e","enemyClone","enemyDelay","enemyTimer","setTimeout","interval","setInterval","fleeCombat"],"sources":["C:/Users/Domin/Desktop/coding/WaveringTides-master/frontend/src/hooks/useCombat.ts"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useInventory } from './useInventory';\nimport { Enemy } from '../types';\nimport { SKILL_IDS, ENEMIES, ITEM_IDS, ITEMS } from '../constants';\n\n/**\n * useCombat hook - Manages combat-related state and operations\n */\nexport const useCombat = () => {\n  const { gameState, updateGameState } = useGameContext();\n  const { addItem } = useInventory();\n  \n  // Use enemies from constants rather than mock data\n  const [enemies] = useState<Enemy[]>(Object.values(ENEMIES));\n  \n  // Local state for combat\n  const [currentEnemy, setCurrentEnemy] = useState<Enemy | null>(null);\n  const [combatLog, setCombatLog] = useState<string[]>([]);\n  const [combatInterval, setCombatInterval] = useState<NodeJS.Timeout | null>(null);\n  const [combatTick, setCombatTick] = useState<number>(0); // Used to trigger combat animations\n  \n  // Track separate timers for player and enemy attacks\n  const [lastPlayerAttack, setLastPlayerAttack] = useState<number>(0);\n  const [lastEnemyAttack, setLastEnemyAttack] = useState<number>(0);\n  const [playerAttackTimer, setPlayerAttackTimer] = useState<NodeJS.Timeout | null>(null);\n  const [enemyAttackTimer, setEnemyAttackTimer] = useState<NodeJS.Timeout | null>(null);\n  \n  // Compute player stats from the game state\n  const getPlayerStats = useCallback(() => {\n    if (!gameState?.player) return { attack: 1, strength: 1, defense: 1, health: 10, maxHealth: 10 };\n    \n    const attack = gameState.player.skills[SKILL_IDS.ATTACK]?.level || 1;\n    const strength = gameState.player.skills[SKILL_IDS.STRENGTH]?.level || 1;\n    const defense = gameState.player.skills[SKILL_IDS.DEFENCE]?.level || 1;\n    \n    // Health is stored as XP in hitpoints skill\n    // If not defined or <= 0, default to 10 (minimum health)\n    const health = Math.max(10, gameState.player.skills[SKILL_IDS.HITPOINTS]?.xp || 10);\n    \n    // Max health calculation: 10 base + 4 per hitpoints level\n    const hitpointsLevel = gameState.player.skills[SKILL_IDS.HITPOINTS]?.level || 1;\n    const maxHealth = 10 + (hitpointsLevel * 4);\n    \n    // Add equipment bonuses\n    const attackBonus = gameState.player.equipment.weapon?.stats?.attackBonus || 0;\n    const strengthBonus = gameState.player.equipment.weapon?.stats?.strengthBonus || 0;\n    const defenseBonus = gameState.player.equipment.armor?.stats?.defenseBonus || 0;\n    \n    return {\n      attack: attack + attackBonus,\n      strength: strength + strengthBonus,\n      defense: defense + defenseBonus,\n      health,\n      maxHealth\n    };\n  }, [gameState]);\n  \n  // Calculate combat stats\n  const playerStats = getPlayerStats();\n  \n  /**\n   * Add a message to the combat log\n   */\n  const addLogMessage = useCallback((message: string) => {\n    setCombatLog(prevLog => [message, ...prevLog].slice(0, 50)); // Keep last 50 messages\n  }, []);\n  \n  /**\n   * Calculate damage based on attacker and defender stats\n   * Improved formula for more balanced combat\n   */\n  const calculateDamage = useCallback((attackerAttack: number, attackerStrength: number, defenderDefense: number) => {\n    try {\n      // Calculate hit chance - improved formula\n      // Higher attack vs defense = better chance to hit\n      const effectiveAttack = attackerAttack + 10; // Increased base value for better early game hit chance\n      const hitChance = Math.min(0.95, Math.max(0.2, effectiveAttack / (effectiveAttack + defenderDefense * 0.7)));\n      const didHit = Math.random() < hitChance;\n      \n      if (!didHit) return 0;\n      \n      // Base damage calculation - improved for more consistent damage\n      // Higher strength = higher potential damage\n      const maxHit = Math.floor(1 + (attackerStrength * 0.15)); // Increased base damage multiplier\n      const damageVariation = 0.7; // 70% variation to make damage more consistent\n      const minDamage = Math.max(1, Math.floor(maxHit * (1 - damageVariation)));\n      const damage = Math.floor(minDamage + Math.random() * (maxHit - minDamage + 1));\n      \n      return Math.max(1, damage); // Always hit at least 1 if the attack lands\n    } catch (error) {\n      console.error('Error calculating damage:', error);\n      return 1; // Fallback to minimum damage on error\n    }\n  }, []);\n  \n  /**\n   * Calculate XP required for next level using OSRS-inspired formula\n   */\n  const calculateXpForNextLevel = useCallback((level: number): number => {\n    return Math.floor(100 * (level ** 1.5));\n  }, []);\n  \n  /**\n   * Handle enemy defeat and loot\n   */\n  const handleEnemyDefeated = useCallback((enemy: Enemy) => {\n    console.log(\"Handling enemy defeat:\", enemy.name);\n    \n    // Stop combat loop\n    if (combatInterval) {\n      console.log(\"Clearing combat interval\");\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    // Stop attack timers\n    if (playerAttackTimer) {\n      console.log(\"Clearing player attack timer\");\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    \n    if (enemyAttackTimer) {\n      console.log(\"Clearing enemy attack timer\");\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n    \n    addLogMessage(`You defeated the ${enemy.name}!`);\n    \n    // Process loot drops\n    const lootMessages: string[] = [];\n    const lootItems: any[] = [];\n    \n    enemy.lootTable.forEach(loot => {\n      if (Math.random() <= loot.chance) {\n        lootMessages.push(`You received ${loot.quantity} ${loot.itemId}!`);\n        \n        // Use the item constants directly\n        const itemName = ITEMS[loot.itemId]?.name || loot.itemId;\n        \n        lootItems.push({\n          id: loot.itemId,\n          name: itemName,\n          quantity: loot.quantity,\n          type: ITEMS[loot.itemId]?.type || 'resource',\n          sellPrice: ITEMS[loot.itemId]?.sellPrice || 5,\n          stats: ITEMS[loot.itemId]?.stats\n        });\n      }\n    });\n    \n    // Award gold\n    const goldAmount = Math.floor(Math.random() * (enemy.maxHealth / 2)) + 5;\n    lootMessages.push(`You found ${goldAmount} gold!`);\n    \n    // Update player state with loot and gold\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      const newState = JSON.parse(JSON.stringify(prevState));\n      \n      // Add gold\n      newState.player.gold += goldAmount;\n      \n      // Add items to inventory - directly update inventory in the state\n      lootItems.forEach(item => {\n        if (newState.player.inventory[item.id]) {\n          newState.player.inventory[item.id].quantity += item.quantity;\n        } else {\n          newState.player.inventory[item.id] = item;\n        }\n      });\n      \n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      \n      return newState;\n    });\n    \n    // Display loot messages\n    lootMessages.forEach(msg => addLogMessage(msg));\n    \n    // Reset current enemy\n    console.log(\"Resetting current enemy to null\");\n    setCurrentEnemy(null);\n  }, [combatInterval, playerAttackTimer, enemyAttackTimer, addLogMessage, updateGameState]);\n  \n  /**\n   * Handle player defeat\n   */\n  const handlePlayerDefeated = useCallback(() => {\n    console.log(\"Handling player defeat\");\n    \n    // Stop combat loop\n    if (combatInterval) {\n      console.log(\"Clearing combat interval\");\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    // Stop attack timers\n    if (playerAttackTimer) {\n      console.log(\"Clearing player attack timer\");\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    \n    if (enemyAttackTimer) {\n      console.log(\"Clearing enemy attack timer\");\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n    \n    addLogMessage('You have been defeated!');\n    \n    // Update player state - reset combat and restore some health\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      const newState = JSON.parse(JSON.stringify(prevState));\n      \n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      \n      // Restore some hitpoints - 25% of max health\n      if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n        const hitpointsLevel = newState.player.skills[SKILL_IDS.HITPOINTS].level || 1;\n        const maxHealth = 10 + (hitpointsLevel * 4);\n        newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.floor(maxHealth * 0.25);\n        addLogMessage('You wake up with some health restored.');\n      }\n      \n      return newState;\n    });\n    \n    // Reset current enemy\n    console.log(\"Resetting current enemy to null\");\n    setCurrentEnemy(null);\n  }, [combatInterval, playerAttackTimer, enemyAttackTimer, addLogMessage, updateGameState]);\n  \n  /**\n   * Calculate player's attack speed in milliseconds\n   * Lower numbers mean faster attacks\n   */\n  const getPlayerAttackSpeed = useCallback(() => {\n    // Base attack speed\n    let attackSpeed = 2000; // Base: 2 seconds between attacks\n    \n    // Factor in weapon type\n    if (gameState?.player?.equipment?.weapon) {\n      const weapon = gameState.player.equipment.weapon;\n      console.log(\"Player weapon found:\", weapon.name);\n      \n      // Different weapons have different speeds\n      if (weapon.id === ITEM_IDS.BRONZE_SWORD) {\n        attackSpeed = 1800; // Swords are faster\n        console.log(\"Sword equipped - base speed is now 1800ms\");\n      }\n      \n      // Weapon quality can further improve speed\n      if (weapon.stats?.attackBonus) {\n        // Each point of attack bonus reduces attack time by 50ms\n        const reduction = weapon.stats.attackBonus * 50;\n        attackSpeed -= reduction;\n        console.log(`Weapon bonus reduces attack time by ${reduction}ms`);\n      }\n    }\n    \n    // Factor in skills - higher attack level = faster attacks\n    const attackLevel = gameState?.player?.skills[SKILL_IDS.ATTACK]?.level || 1;\n    // Each level above 1 reduces attack time by 20ms\n    const levelReduction = (attackLevel - 1) * 20;\n    attackSpeed -= levelReduction;\n    console.log(`Attack level ${attackLevel} reduces attack time by ${levelReduction}ms`);\n    \n    // Ensure attack speed doesn't go below minimum (very fast)\n    const finalSpeed = Math.max(800, attackSpeed);\n    console.log(`Final player attack speed: ${finalSpeed}ms`);\n    return finalSpeed;\n  }, [gameState]);\n  \n  /**\n   * Process player attack\n   */\n  const processPlayerAttack = useCallback(() => {\n    if (!currentEnemy || !gameState?.player) {\n      console.log(\"Cannot process player attack - missing enemy or player data\");\n      return;\n    }\n    \n    console.log(\"Processing player attack against\", currentEnemy.name);\n    \n    // Get current player stats\n    const stats = getPlayerStats();\n    console.log(\"Player stats:\", stats);\n    \n    // Player attacks enemy\n    const playerDamage = calculateDamage(stats.attack, stats.strength, currentEnemy.defense);\n    console.log(\"Player damage calculated:\", playerDamage);\n    \n    if (playerDamage > 0) {\n      // Update enemy health\n      const newEnemyHealth = Math.max(0, currentEnemy.health - playerDamage);\n      console.log(`Enemy health: ${currentEnemy.health} -> ${newEnemyHealth}`);\n      \n      setCurrentEnemy(prev => {\n        if (!prev) return null;\n        const updated = { ...prev, health: newEnemyHealth };\n        console.log(\"Updated enemy:\", updated);\n        return updated;\n      });\n      \n      // Add attack message to combat log\n      addLogMessage(`You hit the ${currentEnemy.name} for ${playerDamage} damage!`);\n      \n      // Trigger animation\n      setCombatTick(prev => prev + 1);\n      \n      // Award combat XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        // Add XP to Attack and Strength\n        if (newState.player.skills[SKILL_IDS.ATTACK]) {\n          const attackXp = playerDamage * 4;\n          const currentAttackXp = newState.player.skills[SKILL_IDS.ATTACK].xp || 0;\n          newState.player.skills[SKILL_IDS.ATTACK].xp = currentAttackXp + attackXp;\n          \n          // Check for level ups\n          const attackLevel = newState.player.skills[SKILL_IDS.ATTACK].level;\n          const xpForNextLevel = calculateXpForNextLevel(attackLevel);\n          if (newState.player.skills[SKILL_IDS.ATTACK].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.ATTACK].level += 1;\n            addLogMessage(`Congratulations! Your Attack level is now ${newState.player.skills[SKILL_IDS.ATTACK].level}`);\n          }\n        }\n        \n        if (newState.player.skills[SKILL_IDS.STRENGTH]) {\n          const strengthXp = playerDamage * 4;\n          const currentStrengthXp = newState.player.skills[SKILL_IDS.STRENGTH].xp || 0;\n          newState.player.skills[SKILL_IDS.STRENGTH].xp = currentStrengthXp + strengthXp;\n          \n          // Check for level ups\n          const strengthLevel = newState.player.skills[SKILL_IDS.STRENGTH].level;\n          const xpForNextLevel = calculateXpForNextLevel(strengthLevel);\n          if (newState.player.skills[SKILL_IDS.STRENGTH].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.STRENGTH].level += 1;\n            addLogMessage(`Congratulations! Your Strength level is now ${newState.player.skills[SKILL_IDS.STRENGTH].level}`);\n          }\n        }\n        \n        return newState;\n      });\n      \n      // Check if enemy is defeated\n      if (newEnemyHealth <= 0) {\n        console.log(\"Enemy defeated!\");\n        handleEnemyDefeated(currentEnemy);\n        return;\n      }\n    } else {\n      addLogMessage(`Your attack missed the ${currentEnemy.name}!`);\n      // Still trigger animation for the miss\n      setCombatTick(prev => prev + 1);\n    }\n    \n    // Schedule next player attack\n    setLastPlayerAttack(Date.now());\n    console.log(\"Player attack completed, next attack scheduled\");\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handleEnemyDefeated]);\n  \n  /**\n   * Process enemy attack\n   */\n  const processEnemyAttack = useCallback(() => {\n    if (!currentEnemy || !gameState?.player) {\n      console.log(\"Cannot process enemy attack - missing enemy or player data\");\n      return;\n    }\n    \n    console.log(\"Processing enemy attack from\", currentEnemy.name);\n    \n    const stats = getPlayerStats();\n    console.log(\"Player stats for defense:\", stats);\n    \n    // Enemy attacks player\n    const enemyDamage = calculateDamage(currentEnemy.attack, currentEnemy.attack, stats.defense);\n    console.log(\"Enemy damage calculated:\", enemyDamage);\n    \n    if (enemyDamage > 0) {\n      addLogMessage(`The ${currentEnemy.name} hits you for ${enemyDamage} damage!`);\n      \n      // Trigger animation\n      setCombatTick(prev => prev + 2); // Use a different number to trigger a different animation\n      \n      // Update player health and award Defense XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        // Add XP to Defense (positive XP for being hit)\n        if (newState.player.skills[SKILL_IDS.DEFENCE]) {\n          const defenseXp = enemyDamage * 4;\n          const currentDefenseXp = newState.player.skills[SKILL_IDS.DEFENCE].xp || 0;\n          newState.player.skills[SKILL_IDS.DEFENCE].xp = currentDefenseXp + defenseXp;\n          \n          // Check for level ups\n          const defenseLevel = newState.player.skills[SKILL_IDS.DEFENCE].level;\n          const xpForNextLevel = calculateXpForNextLevel(defenseLevel);\n          if (newState.player.skills[SKILL_IDS.DEFENCE].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.DEFENCE].level += 1;\n            addLogMessage(`Congratulations! Your Defense level is now ${newState.player.skills[SKILL_IDS.DEFENCE].level}`);\n          }\n        }\n        \n        // Reduce Hitpoints XP (as damage)\n        if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n          const currentHitpointsXp = newState.player.skills[SKILL_IDS.HITPOINTS].xp || 10;\n          const newHitpointsXp = Math.max(0, currentHitpointsXp - enemyDamage);\n          console.log(`Player health: ${currentHitpointsXp} -> ${newHitpointsXp}`);\n          \n          newState.player.skills[SKILL_IDS.HITPOINTS].xp = newHitpointsXp;\n          \n          // Check if player is defeated\n          if (newHitpointsXp <= 0) {\n            console.log(\"Player defeated!\");\n            handlePlayerDefeated();\n          }\n        }\n        \n        return newState;\n      });\n    } else {\n      addLogMessage(`The ${currentEnemy.name}'s attack missed you!`);\n      // Still trigger animation for the miss\n      setCombatTick(prev => prev + 2);\n    }\n    \n    // Schedule next enemy attack\n    setLastEnemyAttack(Date.now());\n    console.log(\"Enemy attack completed, next attack scheduled\");\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handlePlayerDefeated]);\n  \n  /**\n   * Process a single combat round - now manages the timing for both player and enemy attacks\n   */\n  const processCombatRound = useCallback(() => {\n    if (!currentEnemy || !gameState?.player) {\n      console.log(\"Combat round skipped - no enemy or player\");\n      return;\n    }\n    \n    const now = Date.now();\n    const playerSpeed = getPlayerAttackSpeed();\n    const enemySpeed = currentEnemy.attackSpeed || 2000; // Default to 2 seconds if not specified\n    \n    // Check if it's time for player to attack\n    const timeSincePlayerAttack = now - lastPlayerAttack;\n    if (timeSincePlayerAttack >= playerSpeed) {\n      console.log(`Player attack triggered (${timeSincePlayerAttack}ms elapsed, speed: ${playerSpeed}ms)`);\n      processPlayerAttack();\n    }\n    \n    // Check if it's time for enemy to attack\n    const timeSinceEnemyAttack = now - lastEnemyAttack;\n    if (timeSinceEnemyAttack >= enemySpeed) {\n      console.log(`Enemy attack triggered (${timeSinceEnemyAttack}ms elapsed, speed: ${enemySpeed}ms)`);\n      processEnemyAttack();\n    }\n  }, [currentEnemy, gameState, getPlayerAttackSpeed, lastPlayerAttack, lastEnemyAttack, processPlayerAttack, processEnemyAttack]);\n  \n  /**\n   * Start combat with an enemy\n   */\n  const startCombat = useCallback((enemyId: string) => {\n    console.log(\"Starting combat with enemy:\", enemyId);\n    \n    // Stop any existing combat\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    if (playerAttackTimer) {\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    \n    if (enemyAttackTimer) {\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n    \n    // Find the enemy\n    const enemy = enemies.find(e => e.id === enemyId);\n    if (!enemy) {\n      console.error(`Enemy with ID ${enemyId} not found`);\n      return;\n    }\n    \n    // Clone the enemy to avoid modifying the original\n    const enemyClone: Enemy = {\n      ...enemy,\n      health: enemy.maxHealth, // Reset health\n      attackSpeed: enemy.attackSpeed || 2000 // Ensure attackSpeed is set\n    };\n    \n    console.log(\"Enemy clone created:\", enemyClone);\n    \n    setCurrentEnemy(enemyClone);\n    setCombatLog([`Combat started with ${enemyClone.name}!`]);\n    \n    // Reset attack timers\n    const now = Date.now();\n    setLastPlayerAttack(now);\n    setLastEnemyAttack(now);\n    \n    // Update game state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            currentEnemy: enemyClone,\n            isFighting: true\n          }\n        }\n      };\n    });\n    \n    // Process the first player attack immediately\n    console.log(\"Processing first player attack\");\n    processPlayerAttack();\n    \n    // Set up the enemy's first attack with appropriate delay\n    console.log(\"Setting up enemy attack timer\");\n    const enemyDelay = enemyClone.attackSpeed / 2; // Half the enemy's speed for first attack\n    console.log(\"Enemy will attack in\", enemyDelay, \"ms\");\n    \n    const enemyTimer = setTimeout(() => {\n      console.log(\"Processing enemy attack from timer\");\n      processEnemyAttack();\n    }, enemyDelay);\n    \n    setEnemyAttackTimer(enemyTimer);\n    \n    // Start combat loop - check for attacks every 100ms\n    console.log(\"Setting up combat interval\");\n    const interval = setInterval(() => {\n      console.log(\"Combat round check\");\n      processCombatRound();\n    }, 100);\n    setCombatInterval(interval);\n    \n    return () => {\n      console.log(\"Cleaning up combat timers\");\n      clearInterval(interval);\n      clearTimeout(enemyTimer);\n    };\n  }, [enemies, combatInterval, playerAttackTimer, enemyAttackTimer, updateGameState, processCombatRound, processPlayerAttack, processEnemyAttack]);\n  \n  /**\n   * Flee from combat\n   */\n  const fleeCombat = useCallback(() => {\n    if (!currentEnemy) return;\n    \n    // Always succeed at fleeing\n    addLogMessage('You successfully fled from combat!');\n    \n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    // Stop attack timers\n    if (playerAttackTimer) {\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    \n    if (enemyAttackTimer) {\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n    \n    // Update player state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            isFighting: false,\n            currentEnemy: undefined\n          }\n        }\n      };\n    });\n    \n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [currentEnemy, combatInterval, playerAttackTimer, enemyAttackTimer, addLogMessage, updateGameState]);\n  \n  // Clean up interval and timers on unmount\n  useEffect(() => {\n    return () => {\n      if (combatInterval) {\n        clearInterval(combatInterval);\n      }\n      if (playerAttackTimer) {\n        clearTimeout(playerAttackTimer);\n      }\n      if (enemyAttackTimer) {\n        clearTimeout(enemyAttackTimer);\n      }\n    };\n  }, [combatInterval, playerAttackTimer, enemyAttackTimer]);\n  \n  return {\n    enemies,\n    currentEnemy,\n    isFighting: !!currentEnemy,\n    playerStats,\n    combatLog,\n    combatTick, // Expose combat tick for animations\n    startCombat,\n    fleeCombat,\n    processCombatRound // Exposed for manual combat if needed\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}