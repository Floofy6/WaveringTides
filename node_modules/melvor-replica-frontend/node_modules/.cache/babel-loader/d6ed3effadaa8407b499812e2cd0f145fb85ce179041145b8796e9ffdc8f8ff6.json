{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useInventory } from './useInventory';\nimport { SKILL_IDS, ENEMIES, ITEMS } from '../constants';\n\n/**\n * useCombat hook - Manages combat-related state and operations\n */\nexport const useCombat = () => {\n  _s();\n  const {\n    gameState,\n    updateGameState\n  } = useGameContext();\n  const {\n    addItem\n  } = useInventory();\n\n  // Use enemies from constants rather than mock data\n  const [enemies] = useState(Object.values(ENEMIES));\n\n  // Local state for combat\n  const [currentEnemy, setCurrentEnemy] = useState(null);\n  const [combatLog, setCombatLog] = useState([]);\n  const [combatInterval, setCombatInterval] = useState(null);\n  const [combatTick, setCombatTick] = useState(0); // Used to trigger combat animations\n\n  // Compute player stats from the game state\n  const getPlayerStats = useCallback(() => {\n    var _gameState$player$ski, _gameState$player$ski2, _gameState$player$ski3, _gameState$player$ski4, _gameState$player$ski5, _gameState$player$equ, _gameState$player$equ2, _gameState$player$equ3, _gameState$player$equ4, _gameState$player$equ5, _gameState$player$equ6;\n    if (!(gameState !== null && gameState !== void 0 && gameState.player)) return {\n      attack: 1,\n      strength: 1,\n      defense: 1,\n      health: 10,\n      maxHealth: 10\n    };\n    const attack = ((_gameState$player$ski = gameState.player.skills[SKILL_IDS.ATTACK]) === null || _gameState$player$ski === void 0 ? void 0 : _gameState$player$ski.level) || 1;\n    const strength = ((_gameState$player$ski2 = gameState.player.skills[SKILL_IDS.STRENGTH]) === null || _gameState$player$ski2 === void 0 ? void 0 : _gameState$player$ski2.level) || 1;\n    const defense = ((_gameState$player$ski3 = gameState.player.skills[SKILL_IDS.DEFENCE]) === null || _gameState$player$ski3 === void 0 ? void 0 : _gameState$player$ski3.level) || 1;\n\n    // Health is stored as XP in hitpoints skill\n    // If not defined or <= 0, default to 10 (minimum health)\n    const health = Math.max(10, ((_gameState$player$ski4 = gameState.player.skills[SKILL_IDS.HITPOINTS]) === null || _gameState$player$ski4 === void 0 ? void 0 : _gameState$player$ski4.xp) || 10);\n\n    // Max health calculation: 10 base + 4 per hitpoints level\n    const hitpointsLevel = ((_gameState$player$ski5 = gameState.player.skills[SKILL_IDS.HITPOINTS]) === null || _gameState$player$ski5 === void 0 ? void 0 : _gameState$player$ski5.level) || 1;\n    const maxHealth = 10 + hitpointsLevel * 4;\n\n    // Add equipment bonuses\n    const attackBonus = ((_gameState$player$equ = gameState.player.equipment.weapon) === null || _gameState$player$equ === void 0 ? void 0 : (_gameState$player$equ2 = _gameState$player$equ.stats) === null || _gameState$player$equ2 === void 0 ? void 0 : _gameState$player$equ2.attackBonus) || 0;\n    const strengthBonus = ((_gameState$player$equ3 = gameState.player.equipment.weapon) === null || _gameState$player$equ3 === void 0 ? void 0 : (_gameState$player$equ4 = _gameState$player$equ3.stats) === null || _gameState$player$equ4 === void 0 ? void 0 : _gameState$player$equ4.strengthBonus) || 0;\n    const defenseBonus = ((_gameState$player$equ5 = gameState.player.equipment.armor) === null || _gameState$player$equ5 === void 0 ? void 0 : (_gameState$player$equ6 = _gameState$player$equ5.stats) === null || _gameState$player$equ6 === void 0 ? void 0 : _gameState$player$equ6.defenseBonus) || 0;\n    return {\n      attack: attack + attackBonus,\n      strength: strength + strengthBonus,\n      defense: defense + defenseBonus,\n      health,\n      maxHealth\n    };\n  }, [gameState]);\n\n  // Calculate combat stats\n  const playerStats = getPlayerStats();\n\n  /**\n   * Add a message to the combat log\n   */\n  const addLogMessage = useCallback(message => {\n    setCombatLog(prevLog => [message, ...prevLog].slice(0, 50)); // Keep last 50 messages\n  }, []);\n\n  /**\n   * Calculate damage based on attacker and defender stats\n   * Improved formula for more balanced combat\n   */\n  const calculateDamage = useCallback((attackerAttack, attackerStrength, defenderDefense) => {\n    try {\n      // Calculate hit chance - improved formula\n      // Higher attack vs defense = better chance to hit\n      const effectiveAttack = attackerAttack + 10; // Increased base value for better early game hit chance\n      const hitChance = Math.min(0.95, Math.max(0.2, effectiveAttack / (effectiveAttack + defenderDefense * 0.7)));\n      const didHit = Math.random() < hitChance;\n      if (!didHit) return 0;\n\n      // Base damage calculation - improved for more consistent damage\n      // Higher strength = higher potential damage\n      const maxHit = Math.floor(1 + attackerStrength * 0.15); // Increased base damage multiplier\n      const damageVariation = 0.7; // 70% variation to make damage more consistent\n      const minDamage = Math.max(1, Math.floor(maxHit * (1 - damageVariation)));\n      const damage = Math.floor(minDamage + Math.random() * (maxHit - minDamage + 1));\n      return Math.max(1, damage); // Always hit at least 1 if the attack lands\n    } catch (error) {\n      console.error('Error calculating damage:', error);\n      return 1; // Fallback to minimum damage on error\n    }\n  }, []);\n\n  /**\n   * Calculate XP required for next level using OSRS-inspired formula\n   */\n  const calculateXpForNextLevel = useCallback(level => {\n    return Math.floor(100 * level ** 1.5);\n  }, []);\n\n  /**\n   * Handle enemy defeat and loot\n   */\n  const handleEnemyDefeated = useCallback(enemy => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    addLogMessage(`You defeated the ${enemy.name}!`);\n\n    // Process loot drops\n    const lootMessages = [];\n    const lootItems = [];\n    enemy.lootTable.forEach(loot => {\n      if (Math.random() <= loot.chance) {\n        var _ITEMS$loot$itemId, _ITEMS$loot$itemId2, _ITEMS$loot$itemId3, _ITEMS$loot$itemId4;\n        lootMessages.push(`You received ${loot.quantity} ${loot.itemId}!`);\n\n        // Use the item constants directly\n        const itemName = ((_ITEMS$loot$itemId = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId === void 0 ? void 0 : _ITEMS$loot$itemId.name) || loot.itemId;\n        lootItems.push({\n          id: loot.itemId,\n          name: itemName,\n          quantity: loot.quantity,\n          type: ((_ITEMS$loot$itemId2 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId2 === void 0 ? void 0 : _ITEMS$loot$itemId2.type) || 'resource',\n          sellPrice: ((_ITEMS$loot$itemId3 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId3 === void 0 ? void 0 : _ITEMS$loot$itemId3.sellPrice) || 5,\n          stats: (_ITEMS$loot$itemId4 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId4 === void 0 ? void 0 : _ITEMS$loot$itemId4.stats\n        });\n      }\n    });\n\n    // Award gold\n    const goldAmount = Math.floor(Math.random() * (enemy.maxHealth / 2)) + 5;\n    lootMessages.push(`You found ${goldAmount} gold!`);\n\n    // Update player state with loot and gold\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      const newState = JSON.parse(JSON.stringify(prevState));\n\n      // Add gold\n      newState.player.gold += goldAmount;\n\n      // Add items to inventory - directly update inventory in the state\n      lootItems.forEach(item => {\n        if (newState.player.inventory[item.id]) {\n          newState.player.inventory[item.id].quantity += item.quantity;\n        } else {\n          newState.player.inventory[item.id] = item;\n        }\n      });\n\n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      return newState;\n    });\n\n    // Display loot messages\n    lootMessages.forEach(msg => addLogMessage(msg));\n\n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n\n  /**\n   * Handle player defeat\n   */\n  const handlePlayerDefeated = useCallback(() => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    addLogMessage('You have been defeated!');\n\n    // Update player state - reset combat and restore some health\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      const newState = JSON.parse(JSON.stringify(prevState));\n\n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n\n      // Restore some hitpoints - 25% of max health\n      if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n        const hitpointsLevel = newState.player.skills[SKILL_IDS.HITPOINTS].level || 1;\n        const maxHealth = 10 + hitpointsLevel * 4;\n        newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.floor(maxHealth * 0.25);\n        addLogMessage('You wake up with some health restored.');\n      }\n      return newState;\n    });\n\n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n\n  /**\n   * Process a single combat round\n   */\n  const processCombatRound = useCallback(() => {\n    if (!currentEnemy || !(gameState !== null && gameState !== void 0 && gameState.player)) return;\n\n    // Update combat tick for animations\n    setCombatTick(prev => prev + 1);\n\n    // Get current player stats\n    const stats = getPlayerStats();\n\n    // Player attacks enemy\n    const playerDamage = calculateDamage(stats.attack, stats.strength, currentEnemy.defense);\n    if (playerDamage > 0) {\n      // Update enemy health\n      const newEnemyHealth = Math.max(0, currentEnemy.health - playerDamage);\n      setCurrentEnemy(prev => prev ? {\n        ...prev,\n        health: newEnemyHealth\n      } : null);\n\n      // Add attack message to combat log\n      addLogMessage(`You hit the ${currentEnemy.name} for ${playerDamage} damage!`);\n\n      // Award combat XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        const newState = JSON.parse(JSON.stringify(prevState));\n\n        // Add XP to Attack and Strength\n        if (newState.player.skills[SKILL_IDS.ATTACK]) {\n          const attackXp = playerDamage * 4; // 4 XP per damage point\n          const currentAttackXp = newState.player.skills[SKILL_IDS.ATTACK].xp || 0;\n          newState.player.skills[SKILL_IDS.ATTACK].xp = currentAttackXp + attackXp;\n\n          // Check for level ups\n          const attackLevel = newState.player.skills[SKILL_IDS.ATTACK].level;\n          const xpForNextLevel = calculateXpForNextLevel(attackLevel);\n          if (newState.player.skills[SKILL_IDS.ATTACK].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.ATTACK].level += 1;\n            addLogMessage(`Congratulations! Your Attack level is now ${newState.player.skills[SKILL_IDS.ATTACK].level}`);\n          }\n        }\n        if (newState.player.skills[SKILL_IDS.STRENGTH]) {\n          const strengthXp = playerDamage * 4; // 4 XP per damage point\n          const currentStrengthXp = newState.player.skills[SKILL_IDS.STRENGTH].xp || 0;\n          newState.player.skills[SKILL_IDS.STRENGTH].xp = currentStrengthXp + strengthXp;\n\n          // Check for level ups\n          const strengthLevel = newState.player.skills[SKILL_IDS.STRENGTH].level;\n          const xpForNextLevel = calculateXpForNextLevel(strengthLevel);\n          if (newState.player.skills[SKILL_IDS.STRENGTH].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.STRENGTH].level += 1;\n            addLogMessage(`Congratulations! Your Strength level is now ${newState.player.skills[SKILL_IDS.STRENGTH].level}`);\n          }\n        }\n        return newState;\n      });\n\n      // Check if enemy is defeated\n      if (newEnemyHealth <= 0) {\n        handleEnemyDefeated(currentEnemy);\n        return;\n      }\n    } else {\n      addLogMessage(`Your attack missed the ${currentEnemy.name}!`);\n    }\n\n    // Enemy attacks player\n    const enemyDamage = calculateDamage(currentEnemy.attack, currentEnemy.attack, stats.defense);\n    if (enemyDamage > 0) {\n      addLogMessage(`The ${currentEnemy.name} hits you for ${enemyDamage} damage!`);\n\n      // Update player health and award Defense XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        const newState = JSON.parse(JSON.stringify(prevState));\n\n        // Add XP to Defense (positive XP for being hit)\n        if (newState.player.skills[SKILL_IDS.DEFENCE]) {\n          const defenseXp = enemyDamage * 4; // 4 XP per damage point\n          const currentDefenseXp = newState.player.skills[SKILL_IDS.DEFENCE].xp || 0;\n          newState.player.skills[SKILL_IDS.DEFENCE].xp = currentDefenseXp + defenseXp;\n\n          // Check for level ups\n          const defenseLevel = newState.player.skills[SKILL_IDS.DEFENCE].level;\n          const xpForNextLevel = calculateXpForNextLevel(defenseLevel);\n          if (newState.player.skills[SKILL_IDS.DEFENCE].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.DEFENCE].level += 1;\n            addLogMessage(`Congratulations! Your Defense level is now ${newState.player.skills[SKILL_IDS.DEFENCE].level}`);\n          }\n        }\n\n        // Reduce Hitpoints XP (as damage)\n        if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n          const currentHitpointsXp = newState.player.skills[SKILL_IDS.HITPOINTS].xp || 10;\n          newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.max(0, currentHitpointsXp - enemyDamage);\n\n          // Check if player is defeated\n          if (newState.player.skills[SKILL_IDS.HITPOINTS].xp <= 0) {\n            handlePlayerDefeated();\n          }\n        }\n        return newState;\n      });\n    } else {\n      addLogMessage(`The ${currentEnemy.name}'s attack missed you!`);\n    }\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handleEnemyDefeated, handlePlayerDefeated]);\n\n  /**\n   * Start combat with an enemy\n   */\n  const startCombat = useCallback(enemyId => {\n    // Stop any existing combat\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n\n    // Find the enemy\n    const enemy = enemies.find(e => e.id === enemyId);\n    if (!enemy) {\n      console.error(`Enemy with ID ${enemyId} not found`);\n      return;\n    }\n\n    // Clone the enemy to avoid modifying the original\n    const enemyClone = {\n      ...enemy,\n      health: enemy.maxHealth // Reset health\n    };\n    setCurrentEnemy(enemyClone);\n    setCombatLog([`Combat started with ${enemyClone.name}!`]);\n\n    // Update game state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            currentEnemy: enemyClone,\n            isFighting: true\n          }\n        }\n      };\n    });\n\n    // Start combat loop - process combat every 2 seconds\n    // IMPORTANT: Start the first combat round immediately, then set up the interval\n    // This ensures combat progresses without waiting for the first interval tick\n    processCombatRound();\n    const interval = setInterval(processCombatRound, 2000);\n    setCombatInterval(interval);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [enemies, combatInterval, updateGameState, processCombatRound]);\n\n  /**\n   * Flee from combat\n   */\n  const fleeCombat = useCallback(() => {\n    if (!currentEnemy) return;\n\n    // Higher defense gives better flee chance\n    const playerDefense = playerStats.defense;\n    const enemyAttack = currentEnemy.attack;\n    const baseFleeProbability = 0.5; // 50% base chance\n\n    // Defense helps flee, enemy attack makes it harder\n    const fleeChance = Math.min(0.95, Math.max(0.3, baseFleeProbability + (playerDefense - enemyAttack) * 0.05));\n    if (Math.random() <= fleeChance) {\n      addLogMessage('You successfully fled from combat!');\n\n      // Stop combat loop\n      if (combatInterval) {\n        clearInterval(combatInterval);\n        setCombatInterval(null);\n      }\n\n      // Update player state\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        return {\n          ...prevState,\n          player: {\n            ...prevState.player,\n            combat: {\n              isFighting: false,\n              currentEnemy: undefined\n            }\n          }\n        };\n      });\n\n      // Reset current enemy\n      setCurrentEnemy(null);\n    } else {\n      addLogMessage('You failed to flee!');\n\n      // Enemy gets a free attack\n      processCombatRound();\n    }\n  }, [currentEnemy, playerStats, combatInterval, addLogMessage, updateGameState, processCombatRound]);\n\n  // Clean up interval on unmount\n  useEffect(() => {\n    return () => {\n      if (combatInterval) {\n        clearInterval(combatInterval);\n      }\n    };\n  }, [combatInterval]);\n  return {\n    enemies,\n    currentEnemy,\n    isFighting: !!currentEnemy,\n    playerStats,\n    combatLog,\n    combatTick,\n    // Expose combat tick for animations\n    startCombat,\n    fleeCombat,\n    processCombatRound // Exposed for manual combat if needed\n  };\n};\n_s(useCombat, \"k1Efl/LEoV/g5ybXxPIwIZZIC9s=\", false, function () {\n  return [useGameContext, useInventory];\n});","map":{"version":3,"names":["useState","useCallback","useEffect","useGameContext","useInventory","SKILL_IDS","ENEMIES","ITEMS","useCombat","_s","gameState","updateGameState","addItem","enemies","Object","values","currentEnemy","setCurrentEnemy","combatLog","setCombatLog","combatInterval","setCombatInterval","combatTick","setCombatTick","getPlayerStats","_gameState$player$ski","_gameState$player$ski2","_gameState$player$ski3","_gameState$player$ski4","_gameState$player$ski5","_gameState$player$equ","_gameState$player$equ2","_gameState$player$equ3","_gameState$player$equ4","_gameState$player$equ5","_gameState$player$equ6","player","attack","strength","defense","health","maxHealth","skills","ATTACK","level","STRENGTH","DEFENCE","Math","max","HITPOINTS","xp","hitpointsLevel","attackBonus","equipment","weapon","stats","strengthBonus","defenseBonus","armor","playerStats","addLogMessage","message","prevLog","slice","calculateDamage","attackerAttack","attackerStrength","defenderDefense","effectiveAttack","hitChance","min","didHit","random","maxHit","floor","damageVariation","minDamage","damage","error","console","calculateXpForNextLevel","handleEnemyDefeated","enemy","clearInterval","name","lootMessages","lootItems","lootTable","forEach","loot","chance","_ITEMS$loot$itemId","_ITEMS$loot$itemId2","_ITEMS$loot$itemId3","_ITEMS$loot$itemId4","push","quantity","itemId","itemName","id","type","sellPrice","goldAmount","prevState","newState","JSON","parse","stringify","gold","item","inventory","combat","isFighting","undefined","msg","handlePlayerDefeated","processCombatRound","prev","playerDamage","newEnemyHealth","attackXp","currentAttackXp","attackLevel","xpForNextLevel","strengthXp","currentStrengthXp","strengthLevel","enemyDamage","defenseXp","currentDefenseXp","defenseLevel","currentHitpointsXp","startCombat","enemyId","find","e","enemyClone","interval","setInterval","fleeCombat","playerDefense","enemyAttack","baseFleeProbability","fleeChance"],"sources":["C:/Users/Domin/Desktop/coding/WaveringTides-master/frontend/src/hooks/useCombat.ts"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useInventory } from './useInventory';\nimport { Enemy } from '../types';\nimport { SKILL_IDS, ENEMIES, ITEM_IDS, ITEMS } from '../constants';\n\n/**\n * useCombat hook - Manages combat-related state and operations\n */\nexport const useCombat = () => {\n  const { gameState, updateGameState } = useGameContext();\n  const { addItem } = useInventory();\n  \n  // Use enemies from constants rather than mock data\n  const [enemies] = useState<Enemy[]>(Object.values(ENEMIES));\n  \n  // Local state for combat\n  const [currentEnemy, setCurrentEnemy] = useState<Enemy | null>(null);\n  const [combatLog, setCombatLog] = useState<string[]>([]);\n  const [combatInterval, setCombatInterval] = useState<NodeJS.Timeout | null>(null);\n  const [combatTick, setCombatTick] = useState<number>(0); // Used to trigger combat animations\n  \n  // Compute player stats from the game state\n  const getPlayerStats = useCallback(() => {\n    if (!gameState?.player) return { attack: 1, strength: 1, defense: 1, health: 10, maxHealth: 10 };\n    \n    const attack = gameState.player.skills[SKILL_IDS.ATTACK]?.level || 1;\n    const strength = gameState.player.skills[SKILL_IDS.STRENGTH]?.level || 1;\n    const defense = gameState.player.skills[SKILL_IDS.DEFENCE]?.level || 1;\n    \n    // Health is stored as XP in hitpoints skill\n    // If not defined or <= 0, default to 10 (minimum health)\n    const health = Math.max(10, gameState.player.skills[SKILL_IDS.HITPOINTS]?.xp || 10);\n    \n    // Max health calculation: 10 base + 4 per hitpoints level\n    const hitpointsLevel = gameState.player.skills[SKILL_IDS.HITPOINTS]?.level || 1;\n    const maxHealth = 10 + (hitpointsLevel * 4);\n    \n    // Add equipment bonuses\n    const attackBonus = gameState.player.equipment.weapon?.stats?.attackBonus || 0;\n    const strengthBonus = gameState.player.equipment.weapon?.stats?.strengthBonus || 0;\n    const defenseBonus = gameState.player.equipment.armor?.stats?.defenseBonus || 0;\n    \n    return {\n      attack: attack + attackBonus,\n      strength: strength + strengthBonus,\n      defense: defense + defenseBonus,\n      health,\n      maxHealth\n    };\n  }, [gameState]);\n  \n  // Calculate combat stats\n  const playerStats = getPlayerStats();\n  \n  /**\n   * Add a message to the combat log\n   */\n  const addLogMessage = useCallback((message: string) => {\n    setCombatLog(prevLog => [message, ...prevLog].slice(0, 50)); // Keep last 50 messages\n  }, []);\n  \n  /**\n   * Calculate damage based on attacker and defender stats\n   * Improved formula for more balanced combat\n   */\n  const calculateDamage = useCallback((attackerAttack: number, attackerStrength: number, defenderDefense: number) => {\n    try {\n      // Calculate hit chance - improved formula\n      // Higher attack vs defense = better chance to hit\n      const effectiveAttack = attackerAttack + 10; // Increased base value for better early game hit chance\n      const hitChance = Math.min(0.95, Math.max(0.2, effectiveAttack / (effectiveAttack + defenderDefense * 0.7)));\n      const didHit = Math.random() < hitChance;\n      \n      if (!didHit) return 0;\n      \n      // Base damage calculation - improved for more consistent damage\n      // Higher strength = higher potential damage\n      const maxHit = Math.floor(1 + (attackerStrength * 0.15)); // Increased base damage multiplier\n      const damageVariation = 0.7; // 70% variation to make damage more consistent\n      const minDamage = Math.max(1, Math.floor(maxHit * (1 - damageVariation)));\n      const damage = Math.floor(minDamage + Math.random() * (maxHit - minDamage + 1));\n      \n      return Math.max(1, damage); // Always hit at least 1 if the attack lands\n    } catch (error) {\n      console.error('Error calculating damage:', error);\n      return 1; // Fallback to minimum damage on error\n    }\n  }, []);\n  \n  /**\n   * Calculate XP required for next level using OSRS-inspired formula\n   */\n  const calculateXpForNextLevel = useCallback((level: number): number => {\n    return Math.floor(100 * (level ** 1.5));\n  }, []);\n  \n  /**\n   * Handle enemy defeat and loot\n   */\n  const handleEnemyDefeated = useCallback((enemy: Enemy) => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    addLogMessage(`You defeated the ${enemy.name}!`);\n    \n    // Process loot drops\n    const lootMessages: string[] = [];\n    const lootItems: any[] = [];\n    \n    enemy.lootTable.forEach(loot => {\n      if (Math.random() <= loot.chance) {\n        lootMessages.push(`You received ${loot.quantity} ${loot.itemId}!`);\n        \n        // Use the item constants directly\n        const itemName = ITEMS[loot.itemId]?.name || loot.itemId;\n        \n        lootItems.push({\n          id: loot.itemId,\n          name: itemName,\n          quantity: loot.quantity,\n          type: ITEMS[loot.itemId]?.type || 'resource',\n          sellPrice: ITEMS[loot.itemId]?.sellPrice || 5,\n          stats: ITEMS[loot.itemId]?.stats\n        });\n      }\n    });\n    \n    // Award gold\n    const goldAmount = Math.floor(Math.random() * (enemy.maxHealth / 2)) + 5;\n    lootMessages.push(`You found ${goldAmount} gold!`);\n    \n    // Update player state with loot and gold\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      const newState = JSON.parse(JSON.stringify(prevState));\n      \n      // Add gold\n      newState.player.gold += goldAmount;\n      \n      // Add items to inventory - directly update inventory in the state\n      lootItems.forEach(item => {\n        if (newState.player.inventory[item.id]) {\n          newState.player.inventory[item.id].quantity += item.quantity;\n        } else {\n          newState.player.inventory[item.id] = item;\n        }\n      });\n      \n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      \n      return newState;\n    });\n    \n    // Display loot messages\n    lootMessages.forEach(msg => addLogMessage(msg));\n    \n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n  \n  /**\n   * Handle player defeat\n   */\n  const handlePlayerDefeated = useCallback(() => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    addLogMessage('You have been defeated!');\n    \n    // Update player state - reset combat and restore some health\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      const newState = JSON.parse(JSON.stringify(prevState));\n      \n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      \n      // Restore some hitpoints - 25% of max health\n      if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n        const hitpointsLevel = newState.player.skills[SKILL_IDS.HITPOINTS].level || 1;\n        const maxHealth = 10 + (hitpointsLevel * 4);\n        newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.floor(maxHealth * 0.25);\n        addLogMessage('You wake up with some health restored.');\n      }\n      \n      return newState;\n    });\n    \n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n  \n  /**\n   * Process a single combat round\n   */\n  const processCombatRound = useCallback(() => {\n    if (!currentEnemy || !gameState?.player) return;\n    \n    // Update combat tick for animations\n    setCombatTick(prev => prev + 1);\n    \n    // Get current player stats\n    const stats = getPlayerStats();\n    \n    // Player attacks enemy\n    const playerDamage = calculateDamage(stats.attack, stats.strength, currentEnemy.defense);\n    \n    if (playerDamage > 0) {\n      // Update enemy health\n      const newEnemyHealth = Math.max(0, currentEnemy.health - playerDamage);\n      setCurrentEnemy(prev => prev ? { ...prev, health: newEnemyHealth } : null);\n      \n      // Add attack message to combat log\n      addLogMessage(`You hit the ${currentEnemy.name} for ${playerDamage} damage!`);\n      \n      // Award combat XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        // Add XP to Attack and Strength\n        if (newState.player.skills[SKILL_IDS.ATTACK]) {\n          const attackXp = playerDamage * 4; // 4 XP per damage point\n          const currentAttackXp = newState.player.skills[SKILL_IDS.ATTACK].xp || 0;\n          newState.player.skills[SKILL_IDS.ATTACK].xp = currentAttackXp + attackXp;\n          \n          // Check for level ups\n          const attackLevel = newState.player.skills[SKILL_IDS.ATTACK].level;\n          const xpForNextLevel = calculateXpForNextLevel(attackLevel);\n          if (newState.player.skills[SKILL_IDS.ATTACK].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.ATTACK].level += 1;\n            addLogMessage(`Congratulations! Your Attack level is now ${newState.player.skills[SKILL_IDS.ATTACK].level}`);\n          }\n        }\n        \n        if (newState.player.skills[SKILL_IDS.STRENGTH]) {\n          const strengthXp = playerDamage * 4; // 4 XP per damage point\n          const currentStrengthXp = newState.player.skills[SKILL_IDS.STRENGTH].xp || 0;\n          newState.player.skills[SKILL_IDS.STRENGTH].xp = currentStrengthXp + strengthXp;\n          \n          // Check for level ups\n          const strengthLevel = newState.player.skills[SKILL_IDS.STRENGTH].level;\n          const xpForNextLevel = calculateXpForNextLevel(strengthLevel);\n          if (newState.player.skills[SKILL_IDS.STRENGTH].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.STRENGTH].level += 1;\n            addLogMessage(`Congratulations! Your Strength level is now ${newState.player.skills[SKILL_IDS.STRENGTH].level}`);\n          }\n        }\n        \n        return newState;\n      });\n      \n      // Check if enemy is defeated\n      if (newEnemyHealth <= 0) {\n        handleEnemyDefeated(currentEnemy);\n        return;\n      }\n    } else {\n      addLogMessage(`Your attack missed the ${currentEnemy.name}!`);\n    }\n    \n    // Enemy attacks player\n    const enemyDamage = calculateDamage(currentEnemy.attack, currentEnemy.attack, stats.defense);\n    \n    if (enemyDamage > 0) {\n      addLogMessage(`The ${currentEnemy.name} hits you for ${enemyDamage} damage!`);\n      \n      // Update player health and award Defense XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        // Add XP to Defense (positive XP for being hit)\n        if (newState.player.skills[SKILL_IDS.DEFENCE]) {\n          const defenseXp = enemyDamage * 4; // 4 XP per damage point\n          const currentDefenseXp = newState.player.skills[SKILL_IDS.DEFENCE].xp || 0;\n          newState.player.skills[SKILL_IDS.DEFENCE].xp = currentDefenseXp + defenseXp;\n          \n          // Check for level ups\n          const defenseLevel = newState.player.skills[SKILL_IDS.DEFENCE].level;\n          const xpForNextLevel = calculateXpForNextLevel(defenseLevel);\n          if (newState.player.skills[SKILL_IDS.DEFENCE].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.DEFENCE].level += 1;\n            addLogMessage(`Congratulations! Your Defense level is now ${newState.player.skills[SKILL_IDS.DEFENCE].level}`);\n          }\n        }\n        \n        // Reduce Hitpoints XP (as damage)\n        if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n          const currentHitpointsXp = newState.player.skills[SKILL_IDS.HITPOINTS].xp || 10;\n          newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.max(0, currentHitpointsXp - enemyDamage);\n          \n          // Check if player is defeated\n          if (newState.player.skills[SKILL_IDS.HITPOINTS].xp <= 0) {\n            handlePlayerDefeated();\n          }\n        }\n        \n        return newState;\n      });\n    } else {\n      addLogMessage(`The ${currentEnemy.name}'s attack missed you!`);\n    }\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handleEnemyDefeated, handlePlayerDefeated]);\n  \n  /**\n   * Start combat with an enemy\n   */\n  const startCombat = useCallback((enemyId: string) => {\n    // Stop any existing combat\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    // Find the enemy\n    const enemy = enemies.find(e => e.id === enemyId);\n    if (!enemy) {\n      console.error(`Enemy with ID ${enemyId} not found`);\n      return;\n    }\n    \n    // Clone the enemy to avoid modifying the original\n    const enemyClone: Enemy = {\n      ...enemy,\n      health: enemy.maxHealth // Reset health\n    };\n    \n    setCurrentEnemy(enemyClone);\n    setCombatLog([`Combat started with ${enemyClone.name}!`]);\n    \n    // Update game state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            currentEnemy: enemyClone,\n            isFighting: true\n          }\n        }\n      };\n    });\n    \n    // Start combat loop - process combat every 2 seconds\n    // IMPORTANT: Start the first combat round immediately, then set up the interval\n    // This ensures combat progresses without waiting for the first interval tick\n    processCombatRound();\n    \n    const interval = setInterval(processCombatRound, 2000);\n    setCombatInterval(interval);\n    \n    return () => {\n      clearInterval(interval);\n    };\n  }, [enemies, combatInterval, updateGameState, processCombatRound]);\n  \n  /**\n   * Flee from combat\n   */\n  const fleeCombat = useCallback(() => {\n    if (!currentEnemy) return;\n    \n    // Higher defense gives better flee chance\n    const playerDefense = playerStats.defense;\n    const enemyAttack = currentEnemy.attack;\n    const baseFleeProbability = 0.5; // 50% base chance\n    \n    // Defense helps flee, enemy attack makes it harder\n    const fleeChance = Math.min(0.95, Math.max(0.3, baseFleeProbability + (playerDefense - enemyAttack) * 0.05));\n    \n    if (Math.random() <= fleeChance) {\n      addLogMessage('You successfully fled from combat!');\n      \n      // Stop combat loop\n      if (combatInterval) {\n        clearInterval(combatInterval);\n        setCombatInterval(null);\n      }\n      \n      // Update player state\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        return {\n          ...prevState,\n          player: {\n            ...prevState.player,\n            combat: {\n              isFighting: false,\n              currentEnemy: undefined\n            }\n          }\n        };\n      });\n      \n      // Reset current enemy\n      setCurrentEnemy(null);\n    } else {\n      addLogMessage('You failed to flee!');\n      \n      // Enemy gets a free attack\n      processCombatRound();\n    }\n  }, [currentEnemy, playerStats, combatInterval, addLogMessage, updateGameState, processCombatRound]);\n  \n  // Clean up interval on unmount\n  useEffect(() => {\n    return () => {\n      if (combatInterval) {\n        clearInterval(combatInterval);\n      }\n    };\n  }, [combatInterval]);\n  \n  return {\n    enemies,\n    currentEnemy,\n    isFighting: !!currentEnemy,\n    playerStats,\n    combatLog,\n    combatTick, // Expose combat tick for animations\n    startCombat,\n    fleeCombat,\n    processCombatRound // Exposed for manual combat if needed\n  };\n}; "],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,EAAEC,SAAS,QAAQ,OAAO;AACxD,SAASC,cAAc,QAAQ,wBAAwB;AACvD,SAASC,YAAY,QAAQ,gBAAgB;AAE7C,SAASC,SAAS,EAAEC,OAAO,EAAYC,KAAK,QAAQ,cAAc;;AAElE;AACA;AACA;AACA,OAAO,MAAMC,SAAS,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC7B,MAAM;IAAEC,SAAS;IAAEC;EAAgB,CAAC,GAAGR,cAAc,CAAC,CAAC;EACvD,MAAM;IAAES;EAAQ,CAAC,GAAGR,YAAY,CAAC,CAAC;;EAElC;EACA,MAAM,CAACS,OAAO,CAAC,GAAGb,QAAQ,CAAUc,MAAM,CAACC,MAAM,CAACT,OAAO,CAAC,CAAC;;EAE3D;EACA,MAAM,CAACU,YAAY,EAAEC,eAAe,CAAC,GAAGjB,QAAQ,CAAe,IAAI,CAAC;EACpE,MAAM,CAACkB,SAAS,EAAEC,YAAY,CAAC,GAAGnB,QAAQ,CAAW,EAAE,CAAC;EACxD,MAAM,CAACoB,cAAc,EAAEC,iBAAiB,CAAC,GAAGrB,QAAQ,CAAwB,IAAI,CAAC;EACjF,MAAM,CAACsB,UAAU,EAAEC,aAAa,CAAC,GAAGvB,QAAQ,CAAS,CAAC,CAAC,CAAC,CAAC;;EAEzD;EACA,MAAMwB,cAAc,GAAGvB,WAAW,CAAC,MAAM;IAAA,IAAAwB,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA;IACvC,IAAI,EAACzB,SAAS,aAATA,SAAS,eAATA,SAAS,CAAE0B,MAAM,GAAE,OAAO;MAAEC,MAAM,EAAE,CAAC;MAAEC,QAAQ,EAAE,CAAC;MAAEC,OAAO,EAAE,CAAC;MAAEC,MAAM,EAAE,EAAE;MAAEC,SAAS,EAAE;IAAG,CAAC;IAEhG,MAAMJ,MAAM,GAAG,EAAAZ,qBAAA,GAAAf,SAAS,CAAC0B,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACsC,MAAM,CAAC,cAAAlB,qBAAA,uBAAzCA,qBAAA,CAA2CmB,KAAK,KAAI,CAAC;IACpE,MAAMN,QAAQ,GAAG,EAAAZ,sBAAA,GAAAhB,SAAS,CAAC0B,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACwC,QAAQ,CAAC,cAAAnB,sBAAA,uBAA3CA,sBAAA,CAA6CkB,KAAK,KAAI,CAAC;IACxE,MAAML,OAAO,GAAG,EAAAZ,sBAAA,GAAAjB,SAAS,CAAC0B,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACyC,OAAO,CAAC,cAAAnB,sBAAA,uBAA1CA,sBAAA,CAA4CiB,KAAK,KAAI,CAAC;;IAEtE;IACA;IACA,MAAMJ,MAAM,GAAGO,IAAI,CAACC,GAAG,CAAC,EAAE,EAAE,EAAApB,sBAAA,GAAAlB,SAAS,CAAC0B,MAAM,CAACM,MAAM,CAACrC,SAAS,CAAC4C,SAAS,CAAC,cAAArB,sBAAA,uBAA5CA,sBAAA,CAA8CsB,EAAE,KAAI,EAAE,CAAC;;IAEnF;IACA,MAAMC,cAAc,GAAG,EAAAtB,sBAAA,GAAAnB,SAAS,CAAC0B,MAAM,CAACM,MAAM,CAACrC,SAAS,CAAC4C,SAAS,CAAC,cAAApB,sBAAA,uBAA5CA,sBAAA,CAA8Ce,KAAK,KAAI,CAAC;IAC/E,MAAMH,SAAS,GAAG,EAAE,GAAIU,cAAc,GAAG,CAAE;;IAE3C;IACA,MAAMC,WAAW,GAAG,EAAAtB,qBAAA,GAAApB,SAAS,CAAC0B,MAAM,CAACiB,SAAS,CAACC,MAAM,cAAAxB,qBAAA,wBAAAC,sBAAA,GAAjCD,qBAAA,CAAmCyB,KAAK,cAAAxB,sBAAA,uBAAxCA,sBAAA,CAA0CqB,WAAW,KAAI,CAAC;IAC9E,MAAMI,aAAa,GAAG,EAAAxB,sBAAA,GAAAtB,SAAS,CAAC0B,MAAM,CAACiB,SAAS,CAACC,MAAM,cAAAtB,sBAAA,wBAAAC,sBAAA,GAAjCD,sBAAA,CAAmCuB,KAAK,cAAAtB,sBAAA,uBAAxCA,sBAAA,CAA0CuB,aAAa,KAAI,CAAC;IAClF,MAAMC,YAAY,GAAG,EAAAvB,sBAAA,GAAAxB,SAAS,CAAC0B,MAAM,CAACiB,SAAS,CAACK,KAAK,cAAAxB,sBAAA,wBAAAC,sBAAA,GAAhCD,sBAAA,CAAkCqB,KAAK,cAAApB,sBAAA,uBAAvCA,sBAAA,CAAyCsB,YAAY,KAAI,CAAC;IAE/E,OAAO;MACLpB,MAAM,EAAEA,MAAM,GAAGe,WAAW;MAC5Bd,QAAQ,EAAEA,QAAQ,GAAGkB,aAAa;MAClCjB,OAAO,EAAEA,OAAO,GAAGkB,YAAY;MAC/BjB,MAAM;MACNC;IACF,CAAC;EACH,CAAC,EAAE,CAAC/B,SAAS,CAAC,CAAC;;EAEf;EACA,MAAMiD,WAAW,GAAGnC,cAAc,CAAC,CAAC;;EAEpC;AACF;AACA;EACE,MAAMoC,aAAa,GAAG3D,WAAW,CAAE4D,OAAe,IAAK;IACrD1C,YAAY,CAAC2C,OAAO,IAAI,CAACD,OAAO,EAAE,GAAGC,OAAO,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;EAC/D,CAAC,EAAE,EAAE,CAAC;;EAEN;AACF;AACA;AACA;EACE,MAAMC,eAAe,GAAG/D,WAAW,CAAC,CAACgE,cAAsB,EAAEC,gBAAwB,EAAEC,eAAuB,KAAK;IACjH,IAAI;MACF;MACA;MACA,MAAMC,eAAe,GAAGH,cAAc,GAAG,EAAE,CAAC,CAAC;MAC7C,MAAMI,SAAS,GAAGtB,IAAI,CAACuB,GAAG,CAAC,IAAI,EAAEvB,IAAI,CAACC,GAAG,CAAC,GAAG,EAAEoB,eAAe,IAAIA,eAAe,GAAGD,eAAe,GAAG,GAAG,CAAC,CAAC,CAAC;MAC5G,MAAMI,MAAM,GAAGxB,IAAI,CAACyB,MAAM,CAAC,CAAC,GAAGH,SAAS;MAExC,IAAI,CAACE,MAAM,EAAE,OAAO,CAAC;;MAErB;MACA;MACA,MAAME,MAAM,GAAG1B,IAAI,CAAC2B,KAAK,CAAC,CAAC,GAAIR,gBAAgB,GAAG,IAAK,CAAC,CAAC,CAAC;MAC1D,MAAMS,eAAe,GAAG,GAAG,CAAC,CAAC;MAC7B,MAAMC,SAAS,GAAG7B,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAAC2B,KAAK,CAACD,MAAM,IAAI,CAAC,GAAGE,eAAe,CAAC,CAAC,CAAC;MACzE,MAAME,MAAM,GAAG9B,IAAI,CAAC2B,KAAK,CAACE,SAAS,GAAG7B,IAAI,CAACyB,MAAM,CAAC,CAAC,IAAIC,MAAM,GAAGG,SAAS,GAAG,CAAC,CAAC,CAAC;MAE/E,OAAO7B,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE6B,MAAM,CAAC,CAAC,CAAC;IAC9B,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,OAAO,CAAC,CAAC,CAAC;IACZ;EACF,CAAC,EAAE,EAAE,CAAC;;EAEN;AACF;AACA;EACE,MAAME,uBAAuB,GAAG/E,WAAW,CAAE2C,KAAa,IAAa;IACrE,OAAOG,IAAI,CAAC2B,KAAK,CAAC,GAAG,GAAI9B,KAAK,IAAI,GAAI,CAAC;EACzC,CAAC,EAAE,EAAE,CAAC;;EAEN;AACF;AACA;EACE,MAAMqC,mBAAmB,GAAGhF,WAAW,CAAEiF,KAAY,IAAK;IACxD;IACA,IAAI9D,cAAc,EAAE;MAClB+D,aAAa,CAAC/D,cAAc,CAAC;MAC7BC,iBAAiB,CAAC,IAAI,CAAC;IACzB;IAEAuC,aAAa,CAAC,oBAAoBsB,KAAK,CAACE,IAAI,GAAG,CAAC;;IAEhD;IACA,MAAMC,YAAsB,GAAG,EAAE;IACjC,MAAMC,SAAgB,GAAG,EAAE;IAE3BJ,KAAK,CAACK,SAAS,CAACC,OAAO,CAACC,IAAI,IAAI;MAC9B,IAAI1C,IAAI,CAACyB,MAAM,CAAC,CAAC,IAAIiB,IAAI,CAACC,MAAM,EAAE;QAAA,IAAAC,kBAAA,EAAAC,mBAAA,EAAAC,mBAAA,EAAAC,mBAAA;QAChCT,YAAY,CAACU,IAAI,CAAC,gBAAgBN,IAAI,CAACO,QAAQ,IAAIP,IAAI,CAACQ,MAAM,GAAG,CAAC;;QAElE;QACA,MAAMC,QAAQ,GAAG,EAAAP,kBAAA,GAAApF,KAAK,CAACkF,IAAI,CAACQ,MAAM,CAAC,cAAAN,kBAAA,uBAAlBA,kBAAA,CAAoBP,IAAI,KAAIK,IAAI,CAACQ,MAAM;QAExDX,SAAS,CAACS,IAAI,CAAC;UACbI,EAAE,EAAEV,IAAI,CAACQ,MAAM;UACfb,IAAI,EAAEc,QAAQ;UACdF,QAAQ,EAAEP,IAAI,CAACO,QAAQ;UACvBI,IAAI,EAAE,EAAAR,mBAAA,GAAArF,KAAK,CAACkF,IAAI,CAACQ,MAAM,CAAC,cAAAL,mBAAA,uBAAlBA,mBAAA,CAAoBQ,IAAI,KAAI,UAAU;UAC5CC,SAAS,EAAE,EAAAR,mBAAA,GAAAtF,KAAK,CAACkF,IAAI,CAACQ,MAAM,CAAC,cAAAJ,mBAAA,uBAAlBA,mBAAA,CAAoBQ,SAAS,KAAI,CAAC;UAC7C9C,KAAK,GAAAuC,mBAAA,GAAEvF,KAAK,CAACkF,IAAI,CAACQ,MAAM,CAAC,cAAAH,mBAAA,uBAAlBA,mBAAA,CAAoBvC;QAC7B,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;;IAEF;IACA,MAAM+C,UAAU,GAAGvD,IAAI,CAAC2B,KAAK,CAAC3B,IAAI,CAACyB,MAAM,CAAC,CAAC,IAAIU,KAAK,CAACzC,SAAS,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IACxE4C,YAAY,CAACU,IAAI,CAAC,aAAaO,UAAU,QAAQ,CAAC;;IAElD;IACA3F,eAAe,CAAC4F,SAAS,IAAI;MAC3B,IAAI,CAACA,SAAS,EAAE,OAAOA,SAAS;MAEhC,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACJ,SAAS,CAAC,CAAC;;MAEtD;MACAC,QAAQ,CAACpE,MAAM,CAACwE,IAAI,IAAIN,UAAU;;MAElC;MACAhB,SAAS,CAACE,OAAO,CAACqB,IAAI,IAAI;QACxB,IAAIL,QAAQ,CAACpE,MAAM,CAAC0E,SAAS,CAACD,IAAI,CAACV,EAAE,CAAC,EAAE;UACtCK,QAAQ,CAACpE,MAAM,CAAC0E,SAAS,CAACD,IAAI,CAACV,EAAE,CAAC,CAACH,QAAQ,IAAIa,IAAI,CAACb,QAAQ;QAC9D,CAAC,MAAM;UACLQ,QAAQ,CAACpE,MAAM,CAAC0E,SAAS,CAACD,IAAI,CAACV,EAAE,CAAC,GAAGU,IAAI;QAC3C;MACF,CAAC,CAAC;;MAEF;MACAL,QAAQ,CAACpE,MAAM,CAAC2E,MAAM,GAAG;QACvBC,UAAU,EAAE,KAAK;QACjBhG,YAAY,EAAEiG;MAChB,CAAC;MAED,OAAOT,QAAQ;IACjB,CAAC,CAAC;;IAEF;IACAnB,YAAY,CAACG,OAAO,CAAC0B,GAAG,IAAItD,aAAa,CAACsD,GAAG,CAAC,CAAC;;IAE/C;IACAjG,eAAe,CAAC,IAAI,CAAC;EACvB,CAAC,EAAE,CAACG,cAAc,EAAEwC,aAAa,EAAEjD,eAAe,CAAC,CAAC;;EAEpD;AACF;AACA;EACE,MAAMwG,oBAAoB,GAAGlH,WAAW,CAAC,MAAM;IAC7C;IACA,IAAImB,cAAc,EAAE;MAClB+D,aAAa,CAAC/D,cAAc,CAAC;MAC7BC,iBAAiB,CAAC,IAAI,CAAC;IACzB;IAEAuC,aAAa,CAAC,yBAAyB,CAAC;;IAExC;IACAjD,eAAe,CAAC4F,SAAS,IAAI;MAC3B,IAAI,CAACA,SAAS,EAAE,OAAOA,SAAS;MAEhC,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACJ,SAAS,CAAC,CAAC;;MAEtD;MACAC,QAAQ,CAACpE,MAAM,CAAC2E,MAAM,GAAG;QACvBC,UAAU,EAAE,KAAK;QACjBhG,YAAY,EAAEiG;MAChB,CAAC;;MAED;MACA,IAAIT,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAAC4C,SAAS,CAAC,EAAE;QAC/C,MAAME,cAAc,GAAGqD,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAAC4C,SAAS,CAAC,CAACL,KAAK,IAAI,CAAC;QAC7E,MAAMH,SAAS,GAAG,EAAE,GAAIU,cAAc,GAAG,CAAE;QAC3CqD,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAAC4C,SAAS,CAAC,CAACC,EAAE,GAAGH,IAAI,CAAC2B,KAAK,CAACjC,SAAS,GAAG,IAAI,CAAC;QAC7EmB,aAAa,CAAC,wCAAwC,CAAC;MACzD;MAEA,OAAO4C,QAAQ;IACjB,CAAC,CAAC;;IAEF;IACAvF,eAAe,CAAC,IAAI,CAAC;EACvB,CAAC,EAAE,CAACG,cAAc,EAAEwC,aAAa,EAAEjD,eAAe,CAAC,CAAC;;EAEpD;AACF;AACA;EACE,MAAMyG,kBAAkB,GAAGnH,WAAW,CAAC,MAAM;IAC3C,IAAI,CAACe,YAAY,IAAI,EAACN,SAAS,aAATA,SAAS,eAATA,SAAS,CAAE0B,MAAM,GAAE;;IAEzC;IACAb,aAAa,CAAC8F,IAAI,IAAIA,IAAI,GAAG,CAAC,CAAC;;IAE/B;IACA,MAAM9D,KAAK,GAAG/B,cAAc,CAAC,CAAC;;IAE9B;IACA,MAAM8F,YAAY,GAAGtD,eAAe,CAACT,KAAK,CAAClB,MAAM,EAAEkB,KAAK,CAACjB,QAAQ,EAAEtB,YAAY,CAACuB,OAAO,CAAC;IAExF,IAAI+E,YAAY,GAAG,CAAC,EAAE;MACpB;MACA,MAAMC,cAAc,GAAGxE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEhC,YAAY,CAACwB,MAAM,GAAG8E,YAAY,CAAC;MACtErG,eAAe,CAACoG,IAAI,IAAIA,IAAI,GAAG;QAAE,GAAGA,IAAI;QAAE7E,MAAM,EAAE+E;MAAe,CAAC,GAAG,IAAI,CAAC;;MAE1E;MACA3D,aAAa,CAAC,eAAe5C,YAAY,CAACoE,IAAI,QAAQkC,YAAY,UAAU,CAAC;;MAE7E;MACA3G,eAAe,CAAC4F,SAAS,IAAI;QAC3B,IAAI,CAACA,SAAS,EAAE,OAAOA,SAAS;QAEhC,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACJ,SAAS,CAAC,CAAC;;QAEtD;QACA,IAAIC,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACsC,MAAM,CAAC,EAAE;UAC5C,MAAM6E,QAAQ,GAAGF,YAAY,GAAG,CAAC,CAAC,CAAC;UACnC,MAAMG,eAAe,GAAGjB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACsC,MAAM,CAAC,CAACO,EAAE,IAAI,CAAC;UACxEsD,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACsC,MAAM,CAAC,CAACO,EAAE,GAAGuE,eAAe,GAAGD,QAAQ;;UAExE;UACA,MAAME,WAAW,GAAGlB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACsC,MAAM,CAAC,CAACC,KAAK;UAClE,MAAM+E,cAAc,GAAG3C,uBAAuB,CAAC0C,WAAW,CAAC;UAC3D,IAAIlB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACsC,MAAM,CAAC,CAACO,EAAE,IAAIyE,cAAc,EAAE;YACjEnB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACsC,MAAM,CAAC,CAACC,KAAK,IAAI,CAAC;YACnDgB,aAAa,CAAC,6CAA6C4C,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACsC,MAAM,CAAC,CAACC,KAAK,EAAE,CAAC;UAC9G;QACF;QAEA,IAAI4D,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACwC,QAAQ,CAAC,EAAE;UAC9C,MAAM+E,UAAU,GAAGN,YAAY,GAAG,CAAC,CAAC,CAAC;UACrC,MAAMO,iBAAiB,GAAGrB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACwC,QAAQ,CAAC,CAACK,EAAE,IAAI,CAAC;UAC5EsD,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACwC,QAAQ,CAAC,CAACK,EAAE,GAAG2E,iBAAiB,GAAGD,UAAU;;UAE9E;UACA,MAAME,aAAa,GAAGtB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACwC,QAAQ,CAAC,CAACD,KAAK;UACtE,MAAM+E,cAAc,GAAG3C,uBAAuB,CAAC8C,aAAa,CAAC;UAC7D,IAAItB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACwC,QAAQ,CAAC,CAACK,EAAE,IAAIyE,cAAc,EAAE;YACnEnB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACwC,QAAQ,CAAC,CAACD,KAAK,IAAI,CAAC;YACrDgB,aAAa,CAAC,+CAA+C4C,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACwC,QAAQ,CAAC,CAACD,KAAK,EAAE,CAAC;UAClH;QACF;QAEA,OAAO4D,QAAQ;MACjB,CAAC,CAAC;;MAEF;MACA,IAAIe,cAAc,IAAI,CAAC,EAAE;QACvBtC,mBAAmB,CAACjE,YAAY,CAAC;QACjC;MACF;IACF,CAAC,MAAM;MACL4C,aAAa,CAAC,0BAA0B5C,YAAY,CAACoE,IAAI,GAAG,CAAC;IAC/D;;IAEA;IACA,MAAM2C,WAAW,GAAG/D,eAAe,CAAChD,YAAY,CAACqB,MAAM,EAAErB,YAAY,CAACqB,MAAM,EAAEkB,KAAK,CAAChB,OAAO,CAAC;IAE5F,IAAIwF,WAAW,GAAG,CAAC,EAAE;MACnBnE,aAAa,CAAC,OAAO5C,YAAY,CAACoE,IAAI,iBAAiB2C,WAAW,UAAU,CAAC;;MAE7E;MACApH,eAAe,CAAC4F,SAAS,IAAI;QAC3B,IAAI,CAACA,SAAS,EAAE,OAAOA,SAAS;QAEhC,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACJ,SAAS,CAAC,CAAC;;QAEtD;QACA,IAAIC,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACyC,OAAO,CAAC,EAAE;UAC7C,MAAMkF,SAAS,GAAGD,WAAW,GAAG,CAAC,CAAC,CAAC;UACnC,MAAME,gBAAgB,GAAGzB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACyC,OAAO,CAAC,CAACI,EAAE,IAAI,CAAC;UAC1EsD,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACyC,OAAO,CAAC,CAACI,EAAE,GAAG+E,gBAAgB,GAAGD,SAAS;;UAE3E;UACA,MAAME,YAAY,GAAG1B,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACyC,OAAO,CAAC,CAACF,KAAK;UACpE,MAAM+E,cAAc,GAAG3C,uBAAuB,CAACkD,YAAY,CAAC;UAC5D,IAAI1B,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACyC,OAAO,CAAC,CAACI,EAAE,IAAIyE,cAAc,EAAE;YAClEnB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACyC,OAAO,CAAC,CAACF,KAAK,IAAI,CAAC;YACpDgB,aAAa,CAAC,8CAA8C4C,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAACyC,OAAO,CAAC,CAACF,KAAK,EAAE,CAAC;UAChH;QACF;;QAEA;QACA,IAAI4D,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAAC4C,SAAS,CAAC,EAAE;UAC/C,MAAMkF,kBAAkB,GAAG3B,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAAC4C,SAAS,CAAC,CAACC,EAAE,IAAI,EAAE;UAC/EsD,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAAC4C,SAAS,CAAC,CAACC,EAAE,GAAGH,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEmF,kBAAkB,GAAGJ,WAAW,CAAC;;UAE9F;UACA,IAAIvB,QAAQ,CAACpE,MAAM,CAACM,MAAM,CAACrC,SAAS,CAAC4C,SAAS,CAAC,CAACC,EAAE,IAAI,CAAC,EAAE;YACvDiE,oBAAoB,CAAC,CAAC;UACxB;QACF;QAEA,OAAOX,QAAQ;MACjB,CAAC,CAAC;IACJ,CAAC,MAAM;MACL5C,aAAa,CAAC,OAAO5C,YAAY,CAACoE,IAAI,uBAAuB,CAAC;IAChE;EACF,CAAC,EAAE,CAACpE,YAAY,EAAEN,SAAS,EAAEc,cAAc,EAAEwC,eAAe,EAAEJ,aAAa,EAAEjD,eAAe,EAAEqE,uBAAuB,EAAEC,mBAAmB,EAAEkC,oBAAoB,CAAC,CAAC;;EAElK;AACF;AACA;EACE,MAAMiB,WAAW,GAAGnI,WAAW,CAAEoI,OAAe,IAAK;IACnD;IACA,IAAIjH,cAAc,EAAE;MAClB+D,aAAa,CAAC/D,cAAc,CAAC;MAC7BC,iBAAiB,CAAC,IAAI,CAAC;IACzB;;IAEA;IACA,MAAM6D,KAAK,GAAGrE,OAAO,CAACyH,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACpC,EAAE,KAAKkC,OAAO,CAAC;IACjD,IAAI,CAACnD,KAAK,EAAE;MACVH,OAAO,CAACD,KAAK,CAAC,iBAAiBuD,OAAO,YAAY,CAAC;MACnD;IACF;;IAEA;IACA,MAAMG,UAAiB,GAAG;MACxB,GAAGtD,KAAK;MACR1C,MAAM,EAAE0C,KAAK,CAACzC,SAAS,CAAC;IAC1B,CAAC;IAEDxB,eAAe,CAACuH,UAAU,CAAC;IAC3BrH,YAAY,CAAC,CAAC,uBAAuBqH,UAAU,CAACpD,IAAI,GAAG,CAAC,CAAC;;IAEzD;IACAzE,eAAe,CAAC4F,SAAS,IAAI;MAC3B,IAAI,CAACA,SAAS,EAAE,OAAOA,SAAS;MAEhC,OAAO;QACL,GAAGA,SAAS;QACZnE,MAAM,EAAE;UACN,GAAGmE,SAAS,CAACnE,MAAM;UACnB2E,MAAM,EAAE;YACN/F,YAAY,EAAEwH,UAAU;YACxBxB,UAAU,EAAE;UACd;QACF;MACF,CAAC;IACH,CAAC,CAAC;;IAEF;IACA;IACA;IACAI,kBAAkB,CAAC,CAAC;IAEpB,MAAMqB,QAAQ,GAAGC,WAAW,CAACtB,kBAAkB,EAAE,IAAI,CAAC;IACtD/F,iBAAiB,CAACoH,QAAQ,CAAC;IAE3B,OAAO,MAAM;MACXtD,aAAa,CAACsD,QAAQ,CAAC;IACzB,CAAC;EACH,CAAC,EAAE,CAAC5H,OAAO,EAAEO,cAAc,EAAET,eAAe,EAAEyG,kBAAkB,CAAC,CAAC;;EAElE;AACF;AACA;EACE,MAAMuB,UAAU,GAAG1I,WAAW,CAAC,MAAM;IACnC,IAAI,CAACe,YAAY,EAAE;;IAEnB;IACA,MAAM4H,aAAa,GAAGjF,WAAW,CAACpB,OAAO;IACzC,MAAMsG,WAAW,GAAG7H,YAAY,CAACqB,MAAM;IACvC,MAAMyG,mBAAmB,GAAG,GAAG,CAAC,CAAC;;IAEjC;IACA,MAAMC,UAAU,GAAGhG,IAAI,CAACuB,GAAG,CAAC,IAAI,EAAEvB,IAAI,CAACC,GAAG,CAAC,GAAG,EAAE8F,mBAAmB,GAAG,CAACF,aAAa,GAAGC,WAAW,IAAI,IAAI,CAAC,CAAC;IAE5G,IAAI9F,IAAI,CAACyB,MAAM,CAAC,CAAC,IAAIuE,UAAU,EAAE;MAC/BnF,aAAa,CAAC,oCAAoC,CAAC;;MAEnD;MACA,IAAIxC,cAAc,EAAE;QAClB+D,aAAa,CAAC/D,cAAc,CAAC;QAC7BC,iBAAiB,CAAC,IAAI,CAAC;MACzB;;MAEA;MACAV,eAAe,CAAC4F,SAAS,IAAI;QAC3B,IAAI,CAACA,SAAS,EAAE,OAAOA,SAAS;QAEhC,OAAO;UACL,GAAGA,SAAS;UACZnE,MAAM,EAAE;YACN,GAAGmE,SAAS,CAACnE,MAAM;YACnB2E,MAAM,EAAE;cACNC,UAAU,EAAE,KAAK;cACjBhG,YAAY,EAAEiG;YAChB;UACF;QACF,CAAC;MACH,CAAC,CAAC;;MAEF;MACAhG,eAAe,CAAC,IAAI,CAAC;IACvB,CAAC,MAAM;MACL2C,aAAa,CAAC,qBAAqB,CAAC;;MAEpC;MACAwD,kBAAkB,CAAC,CAAC;IACtB;EACF,CAAC,EAAE,CAACpG,YAAY,EAAE2C,WAAW,EAAEvC,cAAc,EAAEwC,aAAa,EAAEjD,eAAe,EAAEyG,kBAAkB,CAAC,CAAC;;EAEnG;EACAlH,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACX,IAAIkB,cAAc,EAAE;QAClB+D,aAAa,CAAC/D,cAAc,CAAC;MAC/B;IACF,CAAC;EACH,CAAC,EAAE,CAACA,cAAc,CAAC,CAAC;EAEpB,OAAO;IACLP,OAAO;IACPG,YAAY;IACZgG,UAAU,EAAE,CAAC,CAAChG,YAAY;IAC1B2C,WAAW;IACXzC,SAAS;IACTI,UAAU;IAAE;IACZ8G,WAAW;IACXO,UAAU;IACVvB,kBAAkB,CAAC;EACrB,CAAC;AACH,CAAC;AAAC3G,EAAA,CAtbWD,SAAS;EAAA,QACmBL,cAAc,EACjCC,YAAY;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}