{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useInventory } from './useInventory';\nimport { SKILL_IDS, ENEMIES } from '../constants';\n\n/**\n * useCombat hook - Manages combat-related state and operations\n */\nexport const useCombat = () => {\n  _s();\n  const {\n    gameState,\n    updateGameState\n  } = useGameContext();\n  const {\n    addItem\n  } = useInventory();\n\n  // Use enemies from constants rather than mock data\n  const [enemies] = useState(Object.values(ENEMIES));\n\n  // Local state for combat\n  const [currentEnemy, setCurrentEnemy] = useState(null);\n  const [combatLog, setCombatLog] = useState([]);\n  const [combatInterval, setCombatInterval] = useState(null);\n  const [combatTick, setCombatTick] = useState(0); // Used to trigger combat animations\n\n  // Compute player stats from the game state\n  const getPlayerStats = useCallback(() => {\n    var _gameState$player$ski, _gameState$player$ski2, _gameState$player$ski3, _gameState$player$ski4, _gameState$player$ski5, _gameState$player$equ, _gameState$player$equ2, _gameState$player$equ3, _gameState$player$equ4, _gameState$player$equ5, _gameState$player$equ6;\n    if (!(gameState !== null && gameState !== void 0 && gameState.player)) return {\n      attack: 1,\n      strength: 1,\n      defense: 1,\n      health: 10,\n      maxHealth: 10\n    };\n    const attack = ((_gameState$player$ski = gameState.player.skills[SKILL_IDS.ATTACK]) === null || _gameState$player$ski === void 0 ? void 0 : _gameState$player$ski.level) || 1;\n    const strength = ((_gameState$player$ski2 = gameState.player.skills[SKILL_IDS.STRENGTH]) === null || _gameState$player$ski2 === void 0 ? void 0 : _gameState$player$ski2.level) || 1;\n    const defense = ((_gameState$player$ski3 = gameState.player.skills[SKILL_IDS.DEFENCE]) === null || _gameState$player$ski3 === void 0 ? void 0 : _gameState$player$ski3.level) || 1;\n\n    // Health is stored as XP in hitpoints skill\n    // If not defined or <= 0, default to 10 (minimum health)\n    const health = Math.max(10, ((_gameState$player$ski4 = gameState.player.skills[SKILL_IDS.HITPOINTS]) === null || _gameState$player$ski4 === void 0 ? void 0 : _gameState$player$ski4.xp) || 10);\n\n    // Max health calculation: 10 base + 4 per hitpoints level\n    const hitpointsLevel = ((_gameState$player$ski5 = gameState.player.skills[SKILL_IDS.HITPOINTS]) === null || _gameState$player$ski5 === void 0 ? void 0 : _gameState$player$ski5.level) || 1;\n    const maxHealth = 10 + hitpointsLevel * 4;\n\n    // Add equipment bonuses\n    const attackBonus = ((_gameState$player$equ = gameState.player.equipment.weapon) === null || _gameState$player$equ === void 0 ? void 0 : (_gameState$player$equ2 = _gameState$player$equ.stats) === null || _gameState$player$equ2 === void 0 ? void 0 : _gameState$player$equ2.attackBonus) || 0;\n    const strengthBonus = ((_gameState$player$equ3 = gameState.player.equipment.weapon) === null || _gameState$player$equ3 === void 0 ? void 0 : (_gameState$player$equ4 = _gameState$player$equ3.stats) === null || _gameState$player$equ4 === void 0 ? void 0 : _gameState$player$equ4.strengthBonus) || 0;\n    const defenseBonus = ((_gameState$player$equ5 = gameState.player.equipment.armor) === null || _gameState$player$equ5 === void 0 ? void 0 : (_gameState$player$equ6 = _gameState$player$equ5.stats) === null || _gameState$player$equ6 === void 0 ? void 0 : _gameState$player$equ6.defenseBonus) || 0;\n    return {\n      attack: attack + attackBonus,\n      strength: strength + strengthBonus,\n      defense: defense + defenseBonus,\n      health,\n      maxHealth\n    };\n  }, [gameState]);\n\n  // Calculate combat stats\n  const playerStats = getPlayerStats();\n\n  /**\n   * Add a message to the combat log\n   */\n  const addLogMessage = useCallback(message => {\n    setCombatLog(prevLog => [message, ...prevLog].slice(0, 50)); // Keep last 50 messages\n  }, []);\n\n  /**\n   * Calculate damage based on attacker and defender stats\n   */\n  const calculateDamage = useCallback((attackerAttack, attackerStrength, defenderDefense) => {\n    // Calculate hit chance - OSRS-like formula\n    // Higher attack vs defense = better chance to hit\n    const effectiveAttack = attackerAttack + 8; // Add a base value for better early game hit chance\n    const hitChance = Math.min(0.95, Math.max(0.1, effectiveAttack / (effectiveAttack + defenderDefense)));\n    const didHit = Math.random() < hitChance;\n    if (!didHit) return 0;\n\n    // Base damage calculation - OSRS-inspired\n    // Higher strength = higher potential damage\n    const maxHit = Math.floor(0.5 + attackerStrength * 0.1);\n    const damage = Math.floor(Math.random() * (maxHit + 1));\n    return Math.max(1, damage); // Always hit at least 1 if the attack lands\n  }, []);\n\n  /**\n   * Process a single combat round\n   */\n  const processCombatRound = useCallback(() => {\n    if (!currentEnemy || !(gameState !== null && gameState !== void 0 && gameState.player)) return;\n\n    // Update combat tick for animations\n    setCombatTick(prev => prev + 1);\n\n    // Get current player stats\n    const stats = getPlayerStats();\n\n    // Player attacks enemy\n    const playerDamage = calculateDamage(stats.attack, stats.strength, currentEnemy.defense);\n    if (playerDamage > 0) {\n      // Update enemy health\n      const newEnemyHealth = Math.max(0, currentEnemy.health - playerDamage);\n      setCurrentEnemy(prev => prev ? {\n        ...prev,\n        health: newEnemyHealth\n      } : null);\n\n      // Add attack message to combat log\n      addLogMessage(`You hit the ${currentEnemy.name} for ${playerDamage} damage!`);\n\n      // Award combat XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        const newState = JSON.parse(JSON.stringify(prevState));\n\n        // Add XP to Attack and Strength\n        if (newState.player.skills[SKILL_IDS.ATTACK]) {\n          const attackXp = playerDamage * 4; // 4 XP per damage point\n          const currentAttackXp = newState.player.skills[SKILL_IDS.ATTACK].xp || 0;\n          newState.player.skills[SKILL_IDS.ATTACK].xp = currentAttackXp + attackXp;\n\n          // Check for level ups\n          const attackLevel = newState.player.skills[SKILL_IDS.ATTACK].level;\n          const xpForNextLevel = calculateXpForNextLevel(attackLevel);\n          if (newState.player.skills[SKILL_IDS.ATTACK].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.ATTACK].level += 1;\n            addLogMessage(`Congratulations! Your Attack level is now ${newState.player.skills[SKILL_IDS.ATTACK].level}`);\n          }\n        }\n        if (newState.player.skills[SKILL_IDS.STRENGTH]) {\n          const strengthXp = playerDamage * 4; // 4 XP per damage point\n          const currentStrengthXp = newState.player.skills[SKILL_IDS.STRENGTH].xp || 0;\n          newState.player.skills[SKILL_IDS.STRENGTH].xp = currentStrengthXp + strengthXp;\n\n          // Check for level ups\n          const strengthLevel = newState.player.skills[SKILL_IDS.STRENGTH].level;\n          const xpForNextLevel = calculateXpForNextLevel(strengthLevel);\n          if (newState.player.skills[SKILL_IDS.STRENGTH].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.STRENGTH].level += 1;\n            addLogMessage(`Congratulations! Your Strength level is now ${newState.player.skills[SKILL_IDS.STRENGTH].level}`);\n          }\n        }\n        return newState;\n      });\n\n      // Check if enemy is defeated\n      if (newEnemyHealth <= 0) {\n        handleEnemyDefeated(currentEnemy);\n        return;\n      }\n    } else {\n      addLogMessage(`Your attack missed the ${currentEnemy.name}!`);\n    }\n\n    // Enemy attacks player\n    const enemyDamage = calculateDamage(currentEnemy.attack, currentEnemy.attack, stats.defense);\n    if (enemyDamage > 0) {\n      addLogMessage(`The ${currentEnemy.name} hits you for ${enemyDamage} damage!`);\n\n      // Update player health and award Defense XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        const newState = JSON.parse(JSON.stringify(prevState));\n\n        // Add XP to Defense (positive XP for being hit)\n        if (newState.player.skills[SKILL_IDS.DEFENCE]) {\n          const defenseXp = enemyDamage * 4; // 4 XP per damage point\n          const currentDefenseXp = newState.player.skills[SKILL_IDS.DEFENCE].xp || 0;\n          newState.player.skills[SKILL_IDS.DEFENCE].xp = currentDefenseXp + defenseXp;\n\n          // Check for level ups\n          const defenseLevel = newState.player.skills[SKILL_IDS.DEFENCE].level;\n          const xpForNextLevel = calculateXpForNextLevel(defenseLevel);\n          if (newState.player.skills[SKILL_IDS.DEFENCE].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.DEFENCE].level += 1;\n            addLogMessage(`Congratulations! Your Defense level is now ${newState.player.skills[SKILL_IDS.DEFENCE].level}`);\n          }\n        }\n\n        // Reduce Hitpoints XP (as damage)\n        if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n          const currentHitpointsXp = newState.player.skills[SKILL_IDS.HITPOINTS].xp || 10;\n          newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.max(0, currentHitpointsXp - enemyDamage);\n\n          // Check if player is defeated\n          if (newState.player.skills[SKILL_IDS.HITPOINTS].xp <= 0) {\n            handlePlayerDefeated();\n          }\n        }\n        return newState;\n      });\n    } else {\n      addLogMessage(`The ${currentEnemy.name}'s attack missed you!`);\n    }\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState]);\n\n  /**\n   * Calculate XP required for next level using OSRS-inspired formula\n   */\n  const calculateXpForNextLevel = useCallback(level => {\n    return Math.floor(100 * level ** 1.5);\n  }, []);\n\n  /**\n   * Start combat with an enemy\n   */\n  const startCombat = useCallback(enemyId => {\n    // Stop any existing combat\n    if (combatInterval) {\n      clearInterval(combatInterval);\n    }\n\n    // Find the enemy\n    const enemy = enemies.find(e => e.id === enemyId);\n    if (!enemy) return;\n\n    // Clone the enemy to avoid modifying the original\n    const enemyClone = {\n      ...enemy,\n      health: enemy.maxHealth // Reset health\n    };\n    setCurrentEnemy(enemyClone);\n    setCombatLog([`Combat started with ${enemyClone.name}!`]);\n\n    // Update game state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            currentEnemy: enemyClone,\n            isFighting: true\n          }\n        }\n      };\n    });\n\n    // Start combat loop - process combat every 2 seconds\n    const interval = setInterval(processCombatRound, 2000);\n    setCombatInterval(interval);\n    return () => clearInterval(interval);\n  }, [enemies, combatInterval, updateGameState, processCombatRound]);\n\n  /**\n   * Handle enemy defeat and loot\n   */\n  const handleEnemyDefeated = useCallback(enemy => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    addLogMessage(`You defeated the ${enemy.name}!`);\n\n    // Process loot drops\n    const lootMessages = [];\n    const lootItems = [];\n    enemy.lootTable.forEach(loot => {\n      if (Math.random() <= loot.chance) {\n        var _ITEMS$loot$itemId, _ITEMS$loot$itemId2, _ITEMS$loot$itemId3, _ITEMS$loot$itemId4;\n        lootMessages.push(`You received ${loot.quantity} ${loot.itemId}!`);\n\n        // Use the item constants directly\n        const itemName = ((_ITEMS$loot$itemId = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId === void 0 ? void 0 : _ITEMS$loot$itemId.name) || loot.itemId;\n        lootItems.push({\n          id: loot.itemId,\n          name: itemName,\n          quantity: loot.quantity,\n          type: ((_ITEMS$loot$itemId2 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId2 === void 0 ? void 0 : _ITEMS$loot$itemId2.type) || 'resource',\n          sellPrice: ((_ITEMS$loot$itemId3 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId3 === void 0 ? void 0 : _ITEMS$loot$itemId3.sellPrice) || 5,\n          stats: (_ITEMS$loot$itemId4 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId4 === void 0 ? void 0 : _ITEMS$loot$itemId4.stats\n        });\n      }\n    });\n\n    // Award gold\n    const goldAmount = Math.floor(Math.random() * (enemy.maxHealth / 2)) + 5;\n    lootMessages.push(`You found ${goldAmount} gold!`);\n\n    // Update player state with loot and gold\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      const newState = JSON.parse(JSON.stringify(prevState));\n\n      // Add gold\n      newState.player.gold += goldAmount;\n\n      // Add items to inventory - directly update inventory in the state\n      lootItems.forEach(item => {\n        if (newState.player.inventory[item.id]) {\n          newState.player.inventory[item.id].quantity += item.quantity;\n        } else {\n          newState.player.inventory[item.id] = item;\n        }\n      });\n\n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      return newState;\n    });\n\n    // Display loot messages\n    lootMessages.forEach(msg => addLogMessage(msg));\n\n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n\n  /**\n   * Handle player defeat\n   */\n  const handlePlayerDefeated = useCallback(() => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    addLogMessage('You have been defeated!');\n\n    // Update player state - reset combat and restore some health\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      const newState = JSON.parse(JSON.stringify(prevState));\n\n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n\n      // Restore some hitpoints - 25% of max health\n      if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n        const hitpointsLevel = newState.player.skills[SKILL_IDS.HITPOINTS].level || 1;\n        const maxHealth = 10 + hitpointsLevel * 4;\n        newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.floor(maxHealth * 0.25);\n        addLogMessage('You wake up with some health restored.');\n      }\n      return newState;\n    });\n\n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n\n  /**\n   * Flee from combat\n   */\n  const fleeCombat = useCallback(() => {\n    if (!currentEnemy) return;\n\n    // Higher defense gives better flee chance\n    const playerDefense = playerStats.defense;\n    const enemyAttack = currentEnemy.attack;\n    const baseFleeProbability = 0.5; // 50% base chance\n\n    // Defense helps flee, enemy attack makes it harder\n    const fleeChance = Math.min(0.95, Math.max(0.3, baseFleeProbability + (playerDefense - enemyAttack) * 0.05));\n    if (Math.random() <= fleeChance) {\n      addLogMessage('You successfully fled from combat!');\n\n      // Stop combat loop\n      if (combatInterval) {\n        clearInterval(combatInterval);\n        setCombatInterval(null);\n      }\n\n      // Update player state\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        return {\n          ...prevState,\n          player: {\n            ...prevState.player,\n            combat: {\n              isFighting: false,\n              currentEnemy: undefined\n            }\n          }\n        };\n      });\n\n      // Reset current enemy\n      setCurrentEnemy(null);\n    } else {\n      addLogMessage('You failed to flee!');\n\n      // Enemy gets a free attack\n      processCombatRound();\n    }\n  }, [currentEnemy, playerStats, combatInterval, addLogMessage, updateGameState, processCombatRound]);\n\n  // Clean up interval on unmount\n  useEffect(() => {\n    return () => {\n      if (combatInterval) {\n        clearInterval(combatInterval);\n      }\n    };\n  }, [combatInterval]);\n  return {\n    enemies,\n    currentEnemy,\n    isFighting: !!currentEnemy,\n    playerStats,\n    combatLog,\n    combatTick,\n    // Expose combat tick for animations\n    startCombat,\n    fleeCombat,\n    processCombatRound // Exposed for manual combat if needed\n  };\n};\n_s(useCombat, \"S1uJeml68AFlLNsisbSLeIoluvY=\", false, function () {\n  return [useGameContext, useInventory];\n});","map":{"version":3,"names":["useState","useCallback","useEffect","useGameContext","useInventory","SKILL_IDS","ENEMIES","useCombat","_s","gameState","updateGameState","addItem","enemies","Object","values","currentEnemy","setCurrentEnemy","combatLog","setCombatLog","combatInterval","setCombatInterval","combatTick","setCombatTick","getPlayerStats","_gameState$player$ski","_gameState$player$ski2","_gameState$player$ski3","_gameState$player$ski4","_gameState$player$ski5","_gameState$player$equ","_gameState$player$equ2","_gameState$player$equ3","_gameState$player$equ4","_gameState$player$equ5","_gameState$player$equ6","player","attack","strength","defense","health","maxHealth","skills","ATTACK","level","STRENGTH","DEFENCE","Math","max","HITPOINTS","xp","hitpointsLevel","attackBonus","equipment","weapon","stats","strengthBonus","defenseBonus","armor","playerStats","addLogMessage","message","prevLog","slice","calculateDamage","attackerAttack","attackerStrength","defenderDefense","effectiveAttack","hitChance","min","didHit","random","maxHit","floor","damage","processCombatRound","prev","playerDamage","newEnemyHealth","name","prevState","newState","JSON","parse","stringify","attackXp","currentAttackXp","attackLevel","xpForNextLevel","calculateXpForNextLevel","strengthXp","currentStrengthXp","strengthLevel","handleEnemyDefeated","enemyDamage","defenseXp","currentDefenseXp","defenseLevel","currentHitpointsXp","handlePlayerDefeated","startCombat","enemyId","clearInterval","enemy","find","e","id","enemyClone","combat","isFighting","interval","setInterval","lootMessages","lootItems","lootTable","forEach","loot","chance","_ITEMS$loot$itemId","_ITEMS$loot$itemId2","_ITEMS$loot$itemId3","_ITEMS$loot$itemId4","push","quantity","itemId","itemName","ITEMS","type","sellPrice","goldAmount","gold","item","inventory","undefined","msg","fleeCombat","playerDefense","enemyAttack","baseFleeProbability","fleeChance"],"sources":["C:/Users/Domin/Desktop/coding/WaveringTides-master/frontend/src/hooks/useCombat.ts"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useInventory } from './useInventory';\nimport { Enemy } from '../types';\nimport { SKILL_IDS, ENEMIES, ITEM_IDS } from '../constants';\n\n/**\n * useCombat hook - Manages combat-related state and operations\n */\nexport const useCombat = () => {\n  const { gameState, updateGameState } = useGameContext();\n  const { addItem } = useInventory();\n  \n  // Use enemies from constants rather than mock data\n  const [enemies] = useState<Enemy[]>(Object.values(ENEMIES));\n  \n  // Local state for combat\n  const [currentEnemy, setCurrentEnemy] = useState<Enemy | null>(null);\n  const [combatLog, setCombatLog] = useState<string[]>([]);\n  const [combatInterval, setCombatInterval] = useState<NodeJS.Timeout | null>(null);\n  const [combatTick, setCombatTick] = useState<number>(0); // Used to trigger combat animations\n  \n  // Compute player stats from the game state\n  const getPlayerStats = useCallback(() => {\n    if (!gameState?.player) return { attack: 1, strength: 1, defense: 1, health: 10, maxHealth: 10 };\n    \n    const attack = gameState.player.skills[SKILL_IDS.ATTACK]?.level || 1;\n    const strength = gameState.player.skills[SKILL_IDS.STRENGTH]?.level || 1;\n    const defense = gameState.player.skills[SKILL_IDS.DEFENCE]?.level || 1;\n    \n    // Health is stored as XP in hitpoints skill\n    // If not defined or <= 0, default to 10 (minimum health)\n    const health = Math.max(10, gameState.player.skills[SKILL_IDS.HITPOINTS]?.xp || 10);\n    \n    // Max health calculation: 10 base + 4 per hitpoints level\n    const hitpointsLevel = gameState.player.skills[SKILL_IDS.HITPOINTS]?.level || 1;\n    const maxHealth = 10 + (hitpointsLevel * 4);\n    \n    // Add equipment bonuses\n    const attackBonus = gameState.player.equipment.weapon?.stats?.attackBonus || 0;\n    const strengthBonus = gameState.player.equipment.weapon?.stats?.strengthBonus || 0;\n    const defenseBonus = gameState.player.equipment.armor?.stats?.defenseBonus || 0;\n    \n    return {\n      attack: attack + attackBonus,\n      strength: strength + strengthBonus,\n      defense: defense + defenseBonus,\n      health,\n      maxHealth\n    };\n  }, [gameState]);\n  \n  // Calculate combat stats\n  const playerStats = getPlayerStats();\n  \n  /**\n   * Add a message to the combat log\n   */\n  const addLogMessage = useCallback((message: string) => {\n    setCombatLog(prevLog => [message, ...prevLog].slice(0, 50)); // Keep last 50 messages\n  }, []);\n  \n  /**\n   * Calculate damage based on attacker and defender stats\n   */\n  const calculateDamage = useCallback((attackerAttack: number, attackerStrength: number, defenderDefense: number) => {\n    // Calculate hit chance - OSRS-like formula\n    // Higher attack vs defense = better chance to hit\n    const effectiveAttack = attackerAttack + 8; // Add a base value for better early game hit chance\n    const hitChance = Math.min(0.95, Math.max(0.1, effectiveAttack / (effectiveAttack + defenderDefense)));\n    const didHit = Math.random() < hitChance;\n    \n    if (!didHit) return 0;\n    \n    // Base damage calculation - OSRS-inspired\n    // Higher strength = higher potential damage\n    const maxHit = Math.floor(0.5 + (attackerStrength * 0.1));\n    const damage = Math.floor(Math.random() * (maxHit + 1));\n    \n    return Math.max(1, damage); // Always hit at least 1 if the attack lands\n  }, []);\n  \n  /**\n   * Process a single combat round\n   */\n  const processCombatRound = useCallback(() => {\n    if (!currentEnemy || !gameState?.player) return;\n    \n    // Update combat tick for animations\n    setCombatTick(prev => prev + 1);\n    \n    // Get current player stats\n    const stats = getPlayerStats();\n    \n    // Player attacks enemy\n    const playerDamage = calculateDamage(stats.attack, stats.strength, currentEnemy.defense);\n    \n    if (playerDamage > 0) {\n      // Update enemy health\n      const newEnemyHealth = Math.max(0, currentEnemy.health - playerDamage);\n      setCurrentEnemy(prev => prev ? { ...prev, health: newEnemyHealth } : null);\n      \n      // Add attack message to combat log\n      addLogMessage(`You hit the ${currentEnemy.name} for ${playerDamage} damage!`);\n      \n      // Award combat XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        // Add XP to Attack and Strength\n        if (newState.player.skills[SKILL_IDS.ATTACK]) {\n          const attackXp = playerDamage * 4; // 4 XP per damage point\n          const currentAttackXp = newState.player.skills[SKILL_IDS.ATTACK].xp || 0;\n          newState.player.skills[SKILL_IDS.ATTACK].xp = currentAttackXp + attackXp;\n          \n          // Check for level ups\n          const attackLevel = newState.player.skills[SKILL_IDS.ATTACK].level;\n          const xpForNextLevel = calculateXpForNextLevel(attackLevel);\n          if (newState.player.skills[SKILL_IDS.ATTACK].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.ATTACK].level += 1;\n            addLogMessage(`Congratulations! Your Attack level is now ${newState.player.skills[SKILL_IDS.ATTACK].level}`);\n          }\n        }\n        \n        if (newState.player.skills[SKILL_IDS.STRENGTH]) {\n          const strengthXp = playerDamage * 4; // 4 XP per damage point\n          const currentStrengthXp = newState.player.skills[SKILL_IDS.STRENGTH].xp || 0;\n          newState.player.skills[SKILL_IDS.STRENGTH].xp = currentStrengthXp + strengthXp;\n          \n          // Check for level ups\n          const strengthLevel = newState.player.skills[SKILL_IDS.STRENGTH].level;\n          const xpForNextLevel = calculateXpForNextLevel(strengthLevel);\n          if (newState.player.skills[SKILL_IDS.STRENGTH].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.STRENGTH].level += 1;\n            addLogMessage(`Congratulations! Your Strength level is now ${newState.player.skills[SKILL_IDS.STRENGTH].level}`);\n          }\n        }\n        \n        return newState;\n      });\n      \n      // Check if enemy is defeated\n      if (newEnemyHealth <= 0) {\n        handleEnemyDefeated(currentEnemy);\n        return;\n      }\n    } else {\n      addLogMessage(`Your attack missed the ${currentEnemy.name}!`);\n    }\n    \n    // Enemy attacks player\n    const enemyDamage = calculateDamage(currentEnemy.attack, currentEnemy.attack, stats.defense);\n    \n    if (enemyDamage > 0) {\n      addLogMessage(`The ${currentEnemy.name} hits you for ${enemyDamage} damage!`);\n      \n      // Update player health and award Defense XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        // Add XP to Defense (positive XP for being hit)\n        if (newState.player.skills[SKILL_IDS.DEFENCE]) {\n          const defenseXp = enemyDamage * 4; // 4 XP per damage point\n          const currentDefenseXp = newState.player.skills[SKILL_IDS.DEFENCE].xp || 0;\n          newState.player.skills[SKILL_IDS.DEFENCE].xp = currentDefenseXp + defenseXp;\n          \n          // Check for level ups\n          const defenseLevel = newState.player.skills[SKILL_IDS.DEFENCE].level;\n          const xpForNextLevel = calculateXpForNextLevel(defenseLevel);\n          if (newState.player.skills[SKILL_IDS.DEFENCE].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.DEFENCE].level += 1;\n            addLogMessage(`Congratulations! Your Defense level is now ${newState.player.skills[SKILL_IDS.DEFENCE].level}`);\n          }\n        }\n        \n        // Reduce Hitpoints XP (as damage)\n        if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n          const currentHitpointsXp = newState.player.skills[SKILL_IDS.HITPOINTS].xp || 10;\n          newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.max(0, currentHitpointsXp - enemyDamage);\n          \n          // Check if player is defeated\n          if (newState.player.skills[SKILL_IDS.HITPOINTS].xp <= 0) {\n            handlePlayerDefeated();\n          }\n        }\n        \n        return newState;\n      });\n    } else {\n      addLogMessage(`The ${currentEnemy.name}'s attack missed you!`);\n    }\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState]);\n  \n  /**\n   * Calculate XP required for next level using OSRS-inspired formula\n   */\n  const calculateXpForNextLevel = useCallback((level: number): number => {\n    return Math.floor(100 * (level ** 1.5));\n  }, []);\n  \n  /**\n   * Start combat with an enemy\n   */\n  const startCombat = useCallback((enemyId: string) => {\n    // Stop any existing combat\n    if (combatInterval) {\n      clearInterval(combatInterval);\n    }\n    \n    // Find the enemy\n    const enemy = enemies.find(e => e.id === enemyId);\n    if (!enemy) return;\n    \n    // Clone the enemy to avoid modifying the original\n    const enemyClone: Enemy = {\n      ...enemy,\n      health: enemy.maxHealth // Reset health\n    };\n    \n    setCurrentEnemy(enemyClone);\n    setCombatLog([`Combat started with ${enemyClone.name}!`]);\n    \n    // Update game state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            currentEnemy: enemyClone,\n            isFighting: true\n          }\n        }\n      };\n    });\n    \n    // Start combat loop - process combat every 2 seconds\n    const interval = setInterval(processCombatRound, 2000);\n    setCombatInterval(interval);\n    \n    return () => clearInterval(interval);\n  }, [enemies, combatInterval, updateGameState, processCombatRound]);\n  \n  /**\n   * Handle enemy defeat and loot\n   */\n  const handleEnemyDefeated = useCallback((enemy: Enemy) => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    addLogMessage(`You defeated the ${enemy.name}!`);\n    \n    // Process loot drops\n    const lootMessages: string[] = [];\n    const lootItems: any[] = [];\n    \n    enemy.lootTable.forEach(loot => {\n      if (Math.random() <= loot.chance) {\n        lootMessages.push(`You received ${loot.quantity} ${loot.itemId}!`);\n        \n        // Use the item constants directly\n        const itemName = ITEMS[loot.itemId]?.name || loot.itemId;\n        \n        lootItems.push({\n          id: loot.itemId,\n          name: itemName,\n          quantity: loot.quantity,\n          type: ITEMS[loot.itemId]?.type || 'resource',\n          sellPrice: ITEMS[loot.itemId]?.sellPrice || 5,\n          stats: ITEMS[loot.itemId]?.stats\n        });\n      }\n    });\n    \n    // Award gold\n    const goldAmount = Math.floor(Math.random() * (enemy.maxHealth / 2)) + 5;\n    lootMessages.push(`You found ${goldAmount} gold!`);\n    \n    // Update player state with loot and gold\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      const newState = JSON.parse(JSON.stringify(prevState));\n      \n      // Add gold\n      newState.player.gold += goldAmount;\n      \n      // Add items to inventory - directly update inventory in the state\n      lootItems.forEach(item => {\n        if (newState.player.inventory[item.id]) {\n          newState.player.inventory[item.id].quantity += item.quantity;\n        } else {\n          newState.player.inventory[item.id] = item;\n        }\n      });\n      \n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      \n      return newState;\n    });\n    \n    // Display loot messages\n    lootMessages.forEach(msg => addLogMessage(msg));\n    \n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n  \n  /**\n   * Handle player defeat\n   */\n  const handlePlayerDefeated = useCallback(() => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    addLogMessage('You have been defeated!');\n    \n    // Update player state - reset combat and restore some health\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      const newState = JSON.parse(JSON.stringify(prevState));\n      \n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      \n      // Restore some hitpoints - 25% of max health\n      if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n        const hitpointsLevel = newState.player.skills[SKILL_IDS.HITPOINTS].level || 1;\n        const maxHealth = 10 + (hitpointsLevel * 4);\n        newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.floor(maxHealth * 0.25);\n        addLogMessage('You wake up with some health restored.');\n      }\n      \n      return newState;\n    });\n    \n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n  \n  /**\n   * Flee from combat\n   */\n  const fleeCombat = useCallback(() => {\n    if (!currentEnemy) return;\n    \n    // Higher defense gives better flee chance\n    const playerDefense = playerStats.defense;\n    const enemyAttack = currentEnemy.attack;\n    const baseFleeProbability = 0.5; // 50% base chance\n    \n    // Defense helps flee, enemy attack makes it harder\n    const fleeChance = Math.min(0.95, Math.max(0.3, baseFleeProbability + (playerDefense - enemyAttack) * 0.05));\n    \n    if (Math.random() <= fleeChance) {\n      addLogMessage('You successfully fled from combat!');\n      \n      // Stop combat loop\n      if (combatInterval) {\n        clearInterval(combatInterval);\n        setCombatInterval(null);\n      }\n      \n      // Update player state\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        return {\n          ...prevState,\n          player: {\n            ...prevState.player,\n            combat: {\n              isFighting: false,\n              currentEnemy: undefined\n            }\n          }\n        };\n      });\n      \n      // Reset current enemy\n      setCurrentEnemy(null);\n    } else {\n      addLogMessage('You failed to flee!');\n      \n      // Enemy gets a free attack\n      processCombatRound();\n    }\n  }, [currentEnemy, playerStats, combatInterval, addLogMessage, updateGameState, processCombatRound]);\n  \n  // Clean up interval on unmount\n  useEffect(() => {\n    return () => {\n      if (combatInterval) {\n        clearInterval(combatInterval);\n      }\n    };\n  }, [combatInterval]);\n  \n  return {\n    enemies,\n    currentEnemy,\n    isFighting: !!currentEnemy,\n    playerStats,\n    combatLog,\n    combatTick, // Expose combat tick for animations\n    startCombat,\n    fleeCombat,\n    processCombatRound // Exposed for manual combat if needed\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}