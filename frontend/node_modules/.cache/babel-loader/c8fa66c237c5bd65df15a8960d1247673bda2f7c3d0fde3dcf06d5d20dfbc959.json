{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useSkills } from '../hooks/useSkills';\n// Helper functions (normally these would be in a separate utils file)\nconst totalXpForLevel = level => {\n  // Simple formula for testing\n  return Math.floor((level - 1) * 100);\n};\nconst getLevelFromXp = xp => {\n  // Simple formula for testing\n  return Math.floor(xp / 100) + 1;\n};\n\n/**\n * GameTick component - Handles game updates at regular intervals\n * This component doesn't render anything but creates a game loop\n */\nconst GameTick = () => {\n  _s();\n  const {\n    getActiveSkills,\n    addExperience,\n    addMasteryExperience\n  } = useSkills();\n  const {\n    gameState,\n    updateGameState\n  } = useGameContext();\n  const lastUpdateRef = useRef(Date.now());\n  const initializedRef = useRef(false);\n\n  // Initialize totalXp for existing skills (for older saves)\n  useEffect(() => {\n    if (!initializedRef.current) {\n      initializedRef.current = true;\n\n      // Check if any skills don't have totalXp and initialize them\n      const needsUpdate = Object.values(gameState.player.skills).some(skill => skill.totalXp === undefined);\n      if (needsUpdate) {\n        console.log('Initializing totalXp for older saves');\n        updateGameState(prevState => {\n          const newState = JSON.parse(JSON.stringify(prevState));\n\n          // Use proper type for skill and ensure all skills have totalXp\n          Object.values(newState.player.skills).forEach(skill => {\n            if (skill.totalXp === undefined) {\n              // Calculate totalXp based on current level and xp\n              const levelBaseXp = totalXpForLevel(skill.level);\n              skill.totalXp = levelBaseXp + (skill.xp || 0);\n\n              // Ensure xp is initialized if missing\n              if (skill.xp === undefined) {\n                skill.xp = 0;\n              }\n\n              // Ensure xpPerAction is initialized if missing\n              if (skill.xpPerAction === undefined) {\n                skill.xpPerAction = 5; // Default value\n                console.warn(`Missing xpPerAction for skill ${skill.name}, initializing to ${skill.xpPerAction}`);\n              }\n            }\n          });\n          return newState;\n        });\n      }\n    }\n  }, [gameState, updateGameState]);\n\n  // Set up game tick for recurring actions\n  useEffect(() => {\n    console.log('GameTick initialized');\n    const tickInterval = 1000; // Update every second\n\n    const gameLoop = () => {\n      const now = Date.now();\n      const deltaTime = now - lastUpdateRef.current;\n      lastUpdateRef.current = now;\n\n      // Get all active skills\n      const activeSkills = getActiveSkills();\n      if (activeSkills.length > 0) {\n        console.log('Active skills:', activeSkills);\n      }\n\n      // Update each active skill\n      activeSkills.forEach(skillId => {\n        const skill = gameState.player.skills[skillId];\n        if (skill) {\n          // Ensure skill has required properties\n          if (typeof skill.xpPerAction !== 'number' || isNaN(skill.xpPerAction)) {\n            console.error(`Skill ${skillId} has invalid xpPerAction: ${skill.xpPerAction}`);\n            return;\n          }\n\n          // Calculate XP gain based on skill's xpPerAction and time elapsed\n          // Increased XP gain for more noticeable progression (50x faster for testing)\n          const xpGain = skill.xpPerAction * (deltaTime / 1000) * 50;\n\n          // Ensure we have a totalXp value\n          if (typeof skill.totalXp !== 'number') {\n            console.warn(`Skill ${skill.name} missing totalXp property, this may cause progress bar issues`);\n          }\n\n          // Add XP to the skill (ensure it's a positive number)\n          addExperience(skillId, Math.max(0, xpGain));\n\n          // If the skill has mastery, add mastery experience as well\n          if (skill.mastery) {\n            // Mastery XP is typically a fraction of regular XP\n            const masteryXpGain = xpGain * 0.5;\n            addMasteryExperience(skillId, masteryXpGain);\n          }\n        } else {\n          console.error(`Skill ${skillId} is active but not found in gameState`);\n        }\n      });\n    };\n\n    // Set up recurring game tick\n    const tickTimer = setInterval(gameLoop, tickInterval);\n\n    // Initial tick\n    gameLoop();\n\n    // Clean up interval on unmount\n    return () => {\n      clearInterval(tickTimer);\n    };\n  }, [gameState, addExperience, addMasteryExperience, getActiveSkills]);\n\n  // This component doesn't render anything\n  return null;\n};\n_s(GameTick, \"xvJo05FxqMHqszDb86B87blClNM=\", false, function () {\n  return [useSkills, useGameContext];\n});\n_c = GameTick;\nexport default GameTick;\nvar _c;\n$RefreshReg$(_c, \"GameTick\");","map":{"version":3,"names":["useEffect","useRef","useGameContext","useSkills","totalXpForLevel","level","Math","floor","getLevelFromXp","xp","GameTick","_s","getActiveSkills","addExperience","addMasteryExperience","gameState","updateGameState","lastUpdateRef","Date","now","initializedRef","current","needsUpdate","Object","values","player","skills","some","skill","totalXp","undefined","console","log","prevState","newState","JSON","parse","stringify","forEach","levelBaseXp","xpPerAction","warn","name","tickInterval","gameLoop","deltaTime","activeSkills","length","skillId","isNaN","error","xpGain","max","mastery","masteryXpGain","tickTimer","setInterval","clearInterval","_c","$RefreshReg$"],"sources":["C:/Users/Domin/Desktop/coding/WaveringTides-master/frontend/src/components/GameTick.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useSkills } from '../hooks/useSkills';\nimport { calculateMasteryXpForLevel } from '../hooks/useSkills';\n\n// Helper functions (normally these would be in a separate utils file)\nconst totalXpForLevel = (level: number): number => {\n  // Simple formula for testing\n  return Math.floor((level - 1) * 100);\n};\n\nconst getLevelFromXp = (xp: number): number => {\n  // Simple formula for testing\n  return Math.floor(xp / 100) + 1;\n};\n\n/**\n * GameTick component - Handles game updates at regular intervals\n * This component doesn't render anything but creates a game loop\n */\nconst GameTick: React.FC = () => {\n  const { getActiveSkills, addExperience, addMasteryExperience } = useSkills();\n  const { gameState, updateGameState } = useGameContext();\n  const lastUpdateRef = useRef<number>(Date.now());\n  const initializedRef = useRef<boolean>(false);\n  \n  // Initialize totalXp for existing skills (for older saves)\n  useEffect(() => {\n    if (!initializedRef.current) {\n      initializedRef.current = true;\n      \n      // Check if any skills don't have totalXp and initialize them\n      const needsUpdate = Object.values(gameState.player.skills).some(\n        (skill: any) => skill.totalXp === undefined\n      );\n      \n      if (needsUpdate) {\n        console.log('Initializing totalXp for older saves');\n        updateGameState((prevState) => {\n          const newState = JSON.parse(JSON.stringify(prevState));\n          \n          // Use proper type for skill and ensure all skills have totalXp\n          Object.values(newState.player.skills).forEach((skill: any) => {\n            if (skill.totalXp === undefined) {\n              // Calculate totalXp based on current level and xp\n              const levelBaseXp = totalXpForLevel(skill.level);\n              skill.totalXp = levelBaseXp + (skill.xp || 0);\n              \n              // Ensure xp is initialized if missing\n              if (skill.xp === undefined) {\n                skill.xp = 0;\n              }\n              \n              // Ensure xpPerAction is initialized if missing\n              if (skill.xpPerAction === undefined) {\n                skill.xpPerAction = 5; // Default value\n                console.warn(`Missing xpPerAction for skill ${skill.name}, initializing to ${skill.xpPerAction}`);\n              }\n            }\n          });\n          \n          return newState;\n        });\n      }\n    }\n  }, [gameState, updateGameState]);\n  \n  // Set up game tick for recurring actions\n  useEffect(() => {\n    console.log('GameTick initialized');\n    \n    const tickInterval = 1000; // Update every second\n    \n    const gameLoop = () => {\n      const now = Date.now();\n      const deltaTime = now - lastUpdateRef.current;\n      lastUpdateRef.current = now;\n      \n      // Get all active skills\n      const activeSkills = getActiveSkills();\n      \n      if (activeSkills.length > 0) {\n        console.log('Active skills:', activeSkills);\n      }\n      \n      // Update each active skill\n      activeSkills.forEach(skillId => {\n        const skill = gameState.player.skills[skillId];\n        if (skill) {\n          // Ensure skill has required properties\n          if (typeof skill.xpPerAction !== 'number' || isNaN(skill.xpPerAction)) {\n            console.error(`Skill ${skillId} has invalid xpPerAction: ${skill.xpPerAction}`);\n            return;\n          }\n          \n          // Calculate XP gain based on skill's xpPerAction and time elapsed\n          // Increased XP gain for more noticeable progression (50x faster for testing)\n          const xpGain = skill.xpPerAction * (deltaTime / 1000) * 50;\n          \n          // Ensure we have a totalXp value\n          if (typeof skill.totalXp !== 'number') {\n            console.warn(`Skill ${skill.name} missing totalXp property, this may cause progress bar issues`);\n          }\n          \n          // Add XP to the skill (ensure it's a positive number)\n          addExperience(skillId, Math.max(0, xpGain));\n          \n          // If the skill has mastery, add mastery experience as well\n          if (skill.mastery) {\n            // Mastery XP is typically a fraction of regular XP\n            const masteryXpGain = xpGain * 0.5;\n            addMasteryExperience(skillId, masteryXpGain);\n          }\n        } else {\n          console.error(`Skill ${skillId} is active but not found in gameState`);\n        }\n      });\n    };\n    \n    // Set up recurring game tick\n    const tickTimer = setInterval(gameLoop, tickInterval);\n    \n    // Initial tick\n    gameLoop();\n    \n    // Clean up interval on unmount\n    return () => {\n      clearInterval(tickTimer);\n    };\n  }, [gameState, addExperience, addMasteryExperience, getActiveSkills]);\n  \n  // This component doesn't render anything\n  return null;\n};\n\nexport default GameTick; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}