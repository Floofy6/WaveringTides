{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useSkills } from '../hooks/useSkills';\n// Helper functions (normally these would be in a separate utils file)\nconst totalXpForLevel = level => {\n  // Simple formula for testing\n  return Math.floor((level - 1) * 100);\n};\nconst getLevelFromXp = xp => {\n  // Simple formula for testing\n  return Math.floor(xp / 100) + 1;\n};\n\n/**\n * GameTick component - Handles game updates at regular intervals\n * This component doesn't render anything but creates a game loop\n */\nconst GameTick = () => {\n  _s();\n  const {\n    getActiveSkills,\n    addExperience,\n    addMasteryExperience\n  } = useSkills();\n  const {\n    gameState,\n    updateGameState\n  } = useGameContext();\n  const lastUpdateRef = useRef(Date.now());\n  const initializedRef = useRef(false);\n\n  // Initialize totalXp for existing skills (for older saves)\n  useEffect(() => {\n    // Safety check: ensure gameState and player exist\n    if (!gameState || !gameState.player || !gameState.player.skills) {\n      console.error(\"GameTick: Cannot initialize totalXp, gameState.player.skills is not available\");\n      return;\n    }\n    if (!initializedRef.current) {\n      initializedRef.current = true;\n      try {\n        // Check if any skills don't have totalXp and initialize them\n        const needsUpdate = Object.values(gameState.player.skills).some(skill => skill && skill.totalXp === undefined);\n        if (needsUpdate) {\n          console.log('Initializing totalXp for older saves');\n          updateGameState(prevState => {\n            // Safety check on prevState\n            if (!prevState || !prevState.player || !prevState.player.skills) {\n              console.error(\"Cannot update skills, prevState.player.skills is missing\");\n              return prevState; // Return unmodified\n            }\n            const newState = JSON.parse(JSON.stringify(prevState));\n\n            // Use proper type for skill and ensure all skills have totalXp\n            Object.values(newState.player.skills).forEach(skill => {\n              if (!skill) return; // Skip if skill is undefined\n\n              if (skill.totalXp === undefined) {\n                // Calculate totalXp based on current level and xp\n                const levelBaseXp = totalXpForLevel(skill.level || 1);\n                skill.totalXp = levelBaseXp + (skill.xp || 0);\n\n                // Ensure xp is initialized if missing\n                if (skill.xp === undefined) {\n                  skill.xp = 0;\n                }\n\n                // Ensure xpPerAction is initialized if missing\n                if (skill.xpPerAction === undefined) {\n                  skill.xpPerAction = 5; // Default value\n                  console.warn(`Missing xpPerAction for skill ${skill.name || 'unknown'}, initializing to ${skill.xpPerAction}`);\n                }\n              }\n            });\n            return newState;\n          });\n        }\n      } catch (error) {\n        console.error(\"Error initializing totalXp:\", error);\n      }\n    }\n  }, [gameState, updateGameState]);\n\n  // Set up game tick for recurring actions\n  useEffect(() => {\n    console.log('GameTick initialized');\n    const tickInterval = 1000; // Update every second\n\n    const gameLoop = () => {\n      try {\n        // Safety check: ensure gameState and player exist\n        if (!gameState || !gameState.player || !gameState.player.skills) {\n          console.error(\"GameTick: gameState.player.skills is not available in game loop\");\n          return;\n        }\n        const now = Date.now();\n        const deltaTime = now - lastUpdateRef.current;\n        lastUpdateRef.current = now;\n\n        // Get all active skills\n        const activeSkills = getActiveSkills();\n        if (activeSkills.length > 0) {\n          console.log('Active skills:', activeSkills);\n        }\n\n        // Update each active skill\n        activeSkills.forEach(skillId => {\n          try {\n            if (!gameState.player.skills[skillId]) {\n              console.error(`Skill ${skillId} is active but not found in gameState`);\n              return;\n            }\n            const skill = gameState.player.skills[skillId];\n\n            // Ensure skill has required properties\n            if (typeof skill.xpPerAction !== 'number' || isNaN(skill.xpPerAction)) {\n              console.error(`Skill ${skillId} has invalid xpPerAction: ${skill.xpPerAction}`);\n              return;\n            }\n\n            // Calculate XP gain based on skill's xpPerAction and time elapsed\n            // Increased XP gain for more noticeable progression (50x faster for testing)\n            const xpGain = skill.xpPerAction * (deltaTime / 1000) * 50;\n\n            // Ensure we have a totalXp value\n            if (typeof skill.totalXp !== 'number') {\n              console.warn(`Skill ${skill.name} missing totalXp property, this may cause progress bar issues`);\n            }\n\n            // Add XP to the skill (ensure it's a positive number)\n            addExperience(skillId, Math.max(0, xpGain));\n\n            // If the skill has mastery, add mastery experience as well\n            if (skill.mastery) {\n              // Mastery XP is typically a fraction of regular XP\n              const masteryXpGain = xpGain * 0.5;\n              addMasteryExperience(skillId, masteryXpGain);\n            }\n          } catch (skillError) {\n            console.error(`Error processing skill ${skillId}:`, skillError);\n          }\n        });\n      } catch (loopError) {\n        console.error(\"Error in game loop:\", loopError);\n      }\n    };\n\n    // Set up recurring game tick\n    const tickTimer = setInterval(gameLoop, tickInterval);\n\n    // Initial tick\n    gameLoop();\n\n    // Clean up interval on unmount\n    return () => {\n      clearInterval(tickTimer);\n    };\n  }, [gameState, addExperience, addMasteryExperience, getActiveSkills]);\n\n  // This component doesn't render anything\n  return null;\n};\n_s(GameTick, \"xvJo05FxqMHqszDb86B87blClNM=\", false, function () {\n  return [useSkills, useGameContext];\n});\n_c = GameTick;\nexport default GameTick;\nvar _c;\n$RefreshReg$(_c, \"GameTick\");","map":{"version":3,"names":["useEffect","useRef","useGameContext","useSkills","totalXpForLevel","level","Math","floor","getLevelFromXp","xp","GameTick","_s","getActiveSkills","addExperience","addMasteryExperience","gameState","updateGameState","lastUpdateRef","Date","now","initializedRef","player","skills","console","error","current","needsUpdate","Object","values","some","skill","totalXp","undefined","log","prevState","newState","JSON","parse","stringify","forEach","levelBaseXp","xpPerAction","warn","name","tickInterval","gameLoop","deltaTime","activeSkills","length","skillId","isNaN","xpGain","max","mastery","masteryXpGain","skillError","loopError","tickTimer","setInterval","clearInterval","_c","$RefreshReg$"],"sources":["C:/Users/Domin/Desktop/coding/WaveringTides-master/frontend/src/components/GameTick.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useSkills } from '../hooks/useSkills';\nimport { calculateMasteryXpForLevel } from '../hooks/useSkills';\n\n// Helper functions (normally these would be in a separate utils file)\nconst totalXpForLevel = (level: number): number => {\n  // Simple formula for testing\n  return Math.floor((level - 1) * 100);\n};\n\nconst getLevelFromXp = (xp: number): number => {\n  // Simple formula for testing\n  return Math.floor(xp / 100) + 1;\n};\n\n/**\n * GameTick component - Handles game updates at regular intervals\n * This component doesn't render anything but creates a game loop\n */\nconst GameTick: React.FC = () => {\n  const { getActiveSkills, addExperience, addMasteryExperience } = useSkills();\n  const { gameState, updateGameState } = useGameContext();\n  const lastUpdateRef = useRef<number>(Date.now());\n  const initializedRef = useRef<boolean>(false);\n  \n  // Initialize totalXp for existing skills (for older saves)\n  useEffect(() => {\n    // Safety check: ensure gameState and player exist\n    if (!gameState || !gameState.player || !gameState.player.skills) {\n      console.error(\"GameTick: Cannot initialize totalXp, gameState.player.skills is not available\");\n      return;\n    }\n    \n    if (!initializedRef.current) {\n      initializedRef.current = true;\n      \n      try {\n        // Check if any skills don't have totalXp and initialize them\n        const needsUpdate = Object.values(gameState.player.skills).some(\n          (skill: any) => skill && skill.totalXp === undefined\n        );\n        \n        if (needsUpdate) {\n          console.log('Initializing totalXp for older saves');\n          updateGameState((prevState) => {\n            // Safety check on prevState\n            if (!prevState || !prevState.player || !prevState.player.skills) {\n              console.error(\"Cannot update skills, prevState.player.skills is missing\");\n              return prevState; // Return unmodified\n            }\n            \n            const newState = JSON.parse(JSON.stringify(prevState));\n            \n            // Use proper type for skill and ensure all skills have totalXp\n            Object.values(newState.player.skills).forEach((skill: any) => {\n              if (!skill) return; // Skip if skill is undefined\n              \n              if (skill.totalXp === undefined) {\n                // Calculate totalXp based on current level and xp\n                const levelBaseXp = totalXpForLevel(skill.level || 1);\n                skill.totalXp = levelBaseXp + (skill.xp || 0);\n                \n                // Ensure xp is initialized if missing\n                if (skill.xp === undefined) {\n                  skill.xp = 0;\n                }\n                \n                // Ensure xpPerAction is initialized if missing\n                if (skill.xpPerAction === undefined) {\n                  skill.xpPerAction = 5; // Default value\n                  console.warn(`Missing xpPerAction for skill ${skill.name || 'unknown'}, initializing to ${skill.xpPerAction}`);\n                }\n              }\n            });\n            \n            return newState;\n          });\n        }\n      } catch (error) {\n        console.error(\"Error initializing totalXp:\", error);\n      }\n    }\n  }, [gameState, updateGameState]);\n  \n  // Set up game tick for recurring actions\n  useEffect(() => {\n    console.log('GameTick initialized');\n    \n    const tickInterval = 1000; // Update every second\n    \n    const gameLoop = () => {\n      try {\n        // Safety check: ensure gameState and player exist\n        if (!gameState || !gameState.player || !gameState.player.skills) {\n          console.error(\"GameTick: gameState.player.skills is not available in game loop\");\n          return;\n        }\n        \n        const now = Date.now();\n        const deltaTime = now - lastUpdateRef.current;\n        lastUpdateRef.current = now;\n        \n        // Get all active skills\n        const activeSkills = getActiveSkills();\n        \n        if (activeSkills.length > 0) {\n          console.log('Active skills:', activeSkills);\n        }\n        \n        // Update each active skill\n        activeSkills.forEach(skillId => {\n          try {\n            if (!gameState.player.skills[skillId]) {\n              console.error(`Skill ${skillId} is active but not found in gameState`);\n              return;\n            }\n            \n            const skill = gameState.player.skills[skillId];\n            \n            // Ensure skill has required properties\n            if (typeof skill.xpPerAction !== 'number' || isNaN(skill.xpPerAction)) {\n              console.error(`Skill ${skillId} has invalid xpPerAction: ${skill.xpPerAction}`);\n              return;\n            }\n            \n            // Calculate XP gain based on skill's xpPerAction and time elapsed\n            // Increased XP gain for more noticeable progression (50x faster for testing)\n            const xpGain = skill.xpPerAction * (deltaTime / 1000) * 50;\n            \n            // Ensure we have a totalXp value\n            if (typeof skill.totalXp !== 'number') {\n              console.warn(`Skill ${skill.name} missing totalXp property, this may cause progress bar issues`);\n            }\n            \n            // Add XP to the skill (ensure it's a positive number)\n            addExperience(skillId, Math.max(0, xpGain));\n            \n            // If the skill has mastery, add mastery experience as well\n            if (skill.mastery) {\n              // Mastery XP is typically a fraction of regular XP\n              const masteryXpGain = xpGain * 0.5;\n              addMasteryExperience(skillId, masteryXpGain);\n            }\n          } catch (skillError) {\n            console.error(`Error processing skill ${skillId}:`, skillError);\n          }\n        });\n      } catch (loopError) {\n        console.error(\"Error in game loop:\", loopError);\n      }\n    };\n    \n    // Set up recurring game tick\n    const tickTimer = setInterval(gameLoop, tickInterval);\n    \n    // Initial tick\n    gameLoop();\n    \n    // Clean up interval on unmount\n    return () => {\n      clearInterval(tickTimer);\n    };\n  }, [gameState, addExperience, addMasteryExperience, getActiveSkills]);\n  \n  // This component doesn't render anything\n  return null;\n};\n\nexport default GameTick; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}