{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nimport { useGameContext } from '../context/GameContext';\n/**\n * Calculate the XP required for the next level based on OSRS formula\n * In OSRS, level 99 requires about 13 million XP\n */\nconst calculateXpForNextLevel = currentLevel => {\n  // OSRS formula: Each level requires points equal to Math.floor(level * 300 * 2^(level/7)) / 4\n  // This is a simplified implementation that closely mimics OSRS XP curve\n  const MAX_LEVEL = 99;\n  if (currentLevel >= MAX_LEVEL) {\n    return Number.MAX_SAFE_INTEGER; // Effectively cap at level 99\n  }\n\n  // Get points required for next level\n  return Math.floor(Math.pow(2, currentLevel / 7) * currentLevel * 300 / 4);\n};\n\n/**\n * Calculate the total XP needed to reach a specific level in OSRS\n */\nconst totalXpForLevel = level => {\n  let total = 0;\n  for (let i = 1; i < level; i++) {\n    total += calculateXpForNextLevel(i);\n  }\n  return total;\n};\n\n/**\n * Get the level based on total XP earned (OSRS style)\n */\nconst getLevelFromXp = totalXp => {\n  let level = 1;\n  while (level < 99 && totalXp >= totalXpForLevel(level + 1)) {\n    level++;\n  }\n  return level;\n};\n\n/**\n * Calculate the XP required for a specific mastery level\n * This uses a different formula than regular skill levels\n */\nexport const calculateMasteryXpForLevel = level => {\n  // Example formula: steeper curve for mastery levels\n  return Math.floor(150 * Math.pow(level, 1.8));\n};\n\n/**\n * useSkills hook - Manages skill-related state and operations\n */\nexport const useSkills = () => {\n  _s();\n  var _gameState$player;\n  const {\n    gameState,\n    updateGameState,\n    loading\n  } = useGameContext();\n  const [currentSkillId, setCurrentSkillId] = useState(null);\n\n  // Use empty object as fallback if player or skills is not available\n  const skills = (gameState === null || gameState === void 0 ? void 0 : (_gameState$player = gameState.player) === null || _gameState$player === void 0 ? void 0 : _gameState$player.skills) || {};\n  const currentSkill = currentSkillId && skills[currentSkillId] ? skills[currentSkillId] : null;\n\n  /**\n   * Select a skill to view its details\n   */\n  const selectSkill = useCallback(skillId => {\n    setCurrentSkillId(skillId);\n  }, []);\n\n  /**\n   * Start a skill activity\n   */\n  const startSkill = useCallback(skillId => {\n    // Safety check\n    if (!gameState || !gameState.player || !gameState.player.skills || !gameState.player.skills[skillId]) {\n      console.error(`Cannot start skill ${skillId}, player data not available`);\n      return;\n    }\n    const updatedSkills = {\n      ...gameState.player.skills,\n      [skillId]: {\n        ...gameState.player.skills[skillId],\n        isActive: true,\n        lastActiveTime: Date.now()\n      }\n    };\n    updateGameState(prevState => {\n      // Safety check\n      if (!prevState || !prevState.player) {\n        console.error(\"Cannot update skills, player data not available\");\n        return prevState;\n      }\n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          skills: updatedSkills\n        }\n      };\n    });\n  }, [gameState, updateGameState]);\n\n  /**\n   * Stop a skill activity\n   */\n  const stopSkill = useCallback(skillId => {\n    // Safety check\n    if (!gameState || !gameState.player || !gameState.player.skills || !gameState.player.skills[skillId]) {\n      console.error(`Cannot stop skill ${skillId}, player data not available`);\n      return;\n    }\n    const updatedSkills = {\n      ...gameState.player.skills,\n      [skillId]: {\n        ...gameState.player.skills[skillId],\n        isActive: false\n      }\n    };\n    updateGameState(prevState => {\n      // Safety check\n      if (!prevState || !prevState.player) {\n        console.error(\"Cannot update skills, player data not available\");\n        return prevState;\n      }\n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          skills: updatedSkills\n        }\n      };\n    });\n  }, [gameState, updateGameState]);\n\n  /**\n   * Add experience to a skill\n   */\n  const addExperience = useCallback((skillId, amount) => {\n    if (loading) return; // Skip if we're loading\n\n    console.log(`Adding ${amount} XP to skill ${skillId}`);\n    updateGameState(prevState => {\n      try {\n        // Safety check\n        if (!prevState || !prevState.player || !prevState.player.skills) {\n          console.error(\"Cannot add experience, player data not available\");\n          return prevState;\n        }\n\n        // Safety check for the skill\n        if (!prevState.player.skills[skillId]) {\n          console.error(`Skill ${skillId} not found`);\n          return prevState;\n        }\n\n        // Create a deep copy of the previous state\n        const newState = JSON.parse(JSON.stringify(prevState));\n\n        // Get the skill\n        const skill = newState.player.skills[skillId];\n\n        // Initialize totalXp if it doesn't exist\n        if (typeof skill.totalXp !== 'number') {\n          // If we don't have totalXp yet, initialize it based on current level and xp\n          const levelBaseXp = totalXpForLevel(skill.level);\n          skill.totalXp = levelBaseXp + (skill.xp || 0);\n        }\n\n        // Add the experience to total XP counter\n        skill.totalXp += amount;\n\n        // Calculate the new level based on total XP\n        const newLevel = getLevelFromXp(skill.totalXp);\n\n        // Check if we leveled up\n        if (newLevel > skill.level) {\n          const oldLevel = skill.level;\n          skill.level = newLevel;\n\n          // Calculate XP within the new level\n          const newLevelBaseXp = totalXpForLevel(newLevel);\n          skill.xp = skill.totalXp - newLevelBaseXp;\n          console.log(`LEVEL UP! ${skill.name} from ${oldLevel} to ${newLevel} (${skill.xp} XP into new level)`);\n        } else {\n          // No level up, just update XP within current level\n          const currentLevelBaseXp = totalXpForLevel(skill.level);\n          skill.xp = skill.totalXp - currentLevelBaseXp;\n          console.log(`Added XP to ${skill.name}: now ${skill.xp}/${calculateXpForNextLevel(skill.level)} within current level`);\n        }\n        return newState;\n      } catch (error) {\n        console.error(\"Error adding experience:\", error);\n        return prevState;\n      }\n    });\n  }, [loading, updateGameState]);\n\n  /**\n   * Get a list of all active skills\n   */\n  const getActiveSkills = useCallback(() => {\n    if (!gameState || !gameState.player || !gameState.player.skills) {\n      return [];\n    }\n    return Object.keys(gameState.player.skills).filter(skillId => {\n      var _gameState$player$ski;\n      return (_gameState$player$ski = gameState.player.skills[skillId]) === null || _gameState$player$ski === void 0 ? void 0 : _gameState$player$ski.isActive;\n    });\n  }, [gameState]);\n\n  /**\n   * Check if a skill has reached a specific level\n   */\n  const hasReachedLevel = useCallback((skillId, level) => {\n    if (!gameState || !gameState.player || !gameState.player.skills) {\n      return false;\n    }\n    const skill = gameState.player.skills[skillId];\n    return skill ? skill.level >= level : false;\n  }, [gameState]);\n\n  /**\n   * Add experience to a skill's mastery and handle level ups\n   */\n  const addMasteryExperience = useCallback((skillId, amount) => {\n    if (loading) return; // Skip if we're loading\n\n    updateGameState(prevState => {\n      try {\n        // Safety check\n        if (!prevState || !prevState.player || !prevState.player.skills) {\n          console.error(\"Cannot add mastery experience, player data not available\");\n          return prevState;\n        }\n\n        // Create a deep copy of the previous state\n        const newState = JSON.parse(JSON.stringify(prevState));\n        const skill = newState.player.skills[skillId];\n        if (!skill || !skill.mastery) {\n          console.error(`Skill ${skillId} or its mastery not found`);\n          return prevState;\n        }\n        const mastery = skill.mastery;\n        let newXp = mastery.xp + amount;\n        let newLevel = mastery.level;\n\n        // Check for level up\n        while (newXp >= calculateMasteryXpForLevel(newLevel + 1)) {\n          newLevel++;\n          console.log(`MASTERY LEVEL UP! ${skill.name} mastery is now level ${newLevel}`);\n        }\n\n        // Update the mastery in the skill\n        skill.mastery = {\n          ...mastery,\n          level: newLevel,\n          xp: newXp\n        };\n        return newState;\n      } catch (error) {\n        console.error(\"Error adding mastery experience:\", error);\n        return prevState;\n      }\n    });\n  }, [loading, updateGameState]);\n  return {\n    skills,\n    currentSkill,\n    selectSkill,\n    startSkill,\n    stopSkill,\n    addExperience,\n    addMasteryExperience,\n    getActiveSkills,\n    hasReachedLevel\n  };\n};\n_s(useSkills, \"xQqYcfKUg0a/Bk+3rTWHoJz+4Bo=\", false, function () {\n  return [useGameContext];\n});","map":{"version":3,"names":["useState","useCallback","useGameContext","calculateXpForNextLevel","currentLevel","MAX_LEVEL","Number","MAX_SAFE_INTEGER","Math","floor","pow","totalXpForLevel","level","total","i","getLevelFromXp","totalXp","calculateMasteryXpForLevel","useSkills","_s","_gameState$player","gameState","updateGameState","loading","currentSkillId","setCurrentSkillId","skills","player","currentSkill","selectSkill","skillId","startSkill","console","error","updatedSkills","isActive","lastActiveTime","Date","now","prevState","stopSkill","addExperience","amount","log","newState","JSON","parse","stringify","skill","levelBaseXp","xp","newLevel","oldLevel","newLevelBaseXp","name","currentLevelBaseXp","getActiveSkills","Object","keys","filter","_gameState$player$ski","hasReachedLevel","addMasteryExperience","mastery","newXp"],"sources":["C:/Users/Domin/Desktop/coding/WaveringTides-master/frontend/src/hooks/useSkills.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { Skill } from '../types';\n\n/**\n * Calculate the XP required for the next level based on OSRS formula\n * In OSRS, level 99 requires about 13 million XP\n */\nconst calculateXpForNextLevel = (currentLevel: number): number => {\n  // OSRS formula: Each level requires points equal to Math.floor(level * 300 * 2^(level/7)) / 4\n  // This is a simplified implementation that closely mimics OSRS XP curve\n  const MAX_LEVEL = 99;\n  \n  if (currentLevel >= MAX_LEVEL) {\n    return Number.MAX_SAFE_INTEGER; // Effectively cap at level 99\n  }\n  \n  // Get points required for next level\n  return Math.floor((Math.pow(2, (currentLevel) / 7) * currentLevel * 300) / 4);\n};\n\n/**\n * Calculate the total XP needed to reach a specific level in OSRS\n */\nconst totalXpForLevel = (level: number): number => {\n  let total = 0;\n  for (let i = 1; i < level; i++) {\n    total += calculateXpForNextLevel(i);\n  }\n  return total;\n};\n\n/**\n * Get the level based on total XP earned (OSRS style)\n */\nconst getLevelFromXp = (totalXp: number): number => {\n  let level = 1;\n  while (level < 99 && totalXp >= totalXpForLevel(level + 1)) {\n    level++;\n  }\n  return level;\n};\n\n/**\n * Calculate the XP required for a specific mastery level\n * This uses a different formula than regular skill levels\n */\nexport const calculateMasteryXpForLevel = (level: number): number => {\n  // Example formula: steeper curve for mastery levels\n  return Math.floor(150 * Math.pow(level, 1.8));\n};\n\n/**\n * useSkills hook - Manages skill-related state and operations\n */\nexport const useSkills = () => {\n  const { gameState, updateGameState, loading } = useGameContext();\n  const [currentSkillId, setCurrentSkillId] = useState<string | null>(null);\n  \n  // Use empty object as fallback if player or skills is not available\n  const skills = gameState?.player?.skills || {};\n  const currentSkill = currentSkillId && skills[currentSkillId] ? skills[currentSkillId] : null;\n  \n  /**\n   * Select a skill to view its details\n   */\n  const selectSkill = useCallback((skillId: string) => {\n    setCurrentSkillId(skillId);\n  }, []);\n  \n  /**\n   * Start a skill activity\n   */\n  const startSkill = useCallback((skillId: string) => {\n    // Safety check\n    if (!gameState || !gameState.player || !gameState.player.skills || !gameState.player.skills[skillId]) {\n      console.error(`Cannot start skill ${skillId}, player data not available`);\n      return;\n    }\n    \n    const updatedSkills = {\n      ...gameState.player.skills,\n      [skillId]: {\n        ...gameState.player.skills[skillId],\n        isActive: true,\n        lastActiveTime: Date.now()\n      }\n    };\n    \n    updateGameState((prevState) => {\n      // Safety check\n      if (!prevState || !prevState.player) {\n        console.error(\"Cannot update skills, player data not available\");\n        return prevState;\n      }\n      \n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          skills: updatedSkills\n        }\n      };\n    });\n  }, [gameState, updateGameState]);\n  \n  /**\n   * Stop a skill activity\n   */\n  const stopSkill = useCallback((skillId: string) => {\n    // Safety check\n    if (!gameState || !gameState.player || !gameState.player.skills || !gameState.player.skills[skillId]) {\n      console.error(`Cannot stop skill ${skillId}, player data not available`);\n      return;\n    }\n    \n    const updatedSkills = {\n      ...gameState.player.skills,\n      [skillId]: {\n        ...gameState.player.skills[skillId],\n        isActive: false\n      }\n    };\n    \n    updateGameState((prevState) => {\n      // Safety check\n      if (!prevState || !prevState.player) {\n        console.error(\"Cannot update skills, player data not available\");\n        return prevState;\n      }\n      \n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          skills: updatedSkills\n        }\n      };\n    });\n  }, [gameState, updateGameState]);\n  \n  /**\n   * Add experience to a skill\n   */\n  const addExperience = useCallback((skillId: string, amount: number): void => {\n    if (loading) return; // Skip if we're loading\n    \n    console.log(`Adding ${amount} XP to skill ${skillId}`);\n    \n    updateGameState((prevState) => {\n      try {\n        // Safety check\n        if (!prevState || !prevState.player || !prevState.player.skills) {\n          console.error(\"Cannot add experience, player data not available\");\n          return prevState;\n        }\n        \n        // Safety check for the skill\n        if (!prevState.player.skills[skillId]) {\n          console.error(`Skill ${skillId} not found`);\n          return prevState;\n        }\n        \n        // Create a deep copy of the previous state\n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        // Get the skill\n        const skill = newState.player.skills[skillId];\n        \n        // Initialize totalXp if it doesn't exist\n        if (typeof skill.totalXp !== 'number') {\n          // If we don't have totalXp yet, initialize it based on current level and xp\n          const levelBaseXp = totalXpForLevel(skill.level);\n          skill.totalXp = levelBaseXp + (skill.xp || 0);\n        }\n        \n        // Add the experience to total XP counter\n        skill.totalXp += amount;\n        \n        // Calculate the new level based on total XP\n        const newLevel = getLevelFromXp(skill.totalXp);\n        \n        // Check if we leveled up\n        if (newLevel > skill.level) {\n          const oldLevel = skill.level;\n          skill.level = newLevel;\n          \n          // Calculate XP within the new level\n          const newLevelBaseXp = totalXpForLevel(newLevel);\n          skill.xp = skill.totalXp - newLevelBaseXp;\n          \n          console.log(`LEVEL UP! ${skill.name} from ${oldLevel} to ${newLevel} (${skill.xp} XP into new level)`);\n        } else {\n          // No level up, just update XP within current level\n          const currentLevelBaseXp = totalXpForLevel(skill.level);\n          skill.xp = skill.totalXp - currentLevelBaseXp;\n          \n          console.log(`Added XP to ${skill.name}: now ${skill.xp}/${calculateXpForNextLevel(skill.level)} within current level`);\n        }\n        \n        return newState;\n      } catch (error) {\n        console.error(\"Error adding experience:\", error);\n        return prevState;\n      }\n    });\n  }, [loading, updateGameState]);\n  \n  /**\n   * Get a list of all active skills\n   */\n  const getActiveSkills = useCallback(() => {\n    if (!gameState || !gameState.player || !gameState.player.skills) {\n      return [];\n    }\n    \n    return Object.keys(gameState.player.skills).filter(\n      skillId => gameState.player.skills[skillId]?.isActive\n    );\n  }, [gameState]);\n  \n  /**\n   * Check if a skill has reached a specific level\n   */\n  const hasReachedLevel = useCallback((skillId: string, level: number) => {\n    if (!gameState || !gameState.player || !gameState.player.skills) {\n      return false;\n    }\n    \n    const skill = gameState.player.skills[skillId];\n    return skill ? skill.level >= level : false;\n  }, [gameState]);\n  \n  /**\n   * Add experience to a skill's mastery and handle level ups\n   */\n  const addMasteryExperience = useCallback((skillId: string, amount: number) => {\n    if (loading) return; // Skip if we're loading\n    \n    updateGameState((prevState) => {\n      try {\n        // Safety check\n        if (!prevState || !prevState.player || !prevState.player.skills) {\n          console.error(\"Cannot add mastery experience, player data not available\");\n          return prevState;\n        }\n        \n        // Create a deep copy of the previous state\n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        const skill = newState.player.skills[skillId];\n        if (!skill || !skill.mastery) {\n          console.error(`Skill ${skillId} or its mastery not found`);\n          return prevState;\n        }\n        \n        const mastery = skill.mastery;\n        let newXp = mastery.xp + amount;\n        let newLevel = mastery.level;\n        \n        // Check for level up\n        while (newXp >= calculateMasteryXpForLevel(newLevel + 1)) {\n          newLevel++;\n          console.log(`MASTERY LEVEL UP! ${skill.name} mastery is now level ${newLevel}`);\n        }\n        \n        // Update the mastery in the skill\n        skill.mastery = {\n          ...mastery,\n          level: newLevel,\n          xp: newXp\n        };\n        \n        return newState;\n      } catch (error) {\n        console.error(\"Error adding mastery experience:\", error);\n        return prevState;\n      }\n    });\n  }, [loading, updateGameState]);\n  \n  return {\n    skills,\n    currentSkill,\n    selectSkill,\n    startSkill,\n    stopSkill,\n    addExperience,\n    addMasteryExperience,\n    getActiveSkills,\n    hasReachedLevel\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}