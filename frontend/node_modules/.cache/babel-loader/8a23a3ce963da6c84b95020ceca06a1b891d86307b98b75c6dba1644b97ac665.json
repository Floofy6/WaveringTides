{"ast":null,"code":"/**\r\n * Storage utilities for safely handling localStorage operations\r\n */\n\n// Maximum size for localStorage items (5MB is a safe limit for most browsers)\nconst MAX_STORAGE_SIZE = 5 * 1024 * 1024; // 5MB in bytes\n\n/**\r\n * Safely save data to localStorage with size checking\r\n * @param key The localStorage key\r\n * @param data The data to save\r\n * @returns true if save was successful, false otherwise\r\n */\nexport const safeSetItem = (key, data) => {\n  try {\n    // Convert data to JSON string\n    const jsonString = typeof data === 'string' ? data : JSON.stringify(data);\n\n    // Check size\n    if (jsonString.length > MAX_STORAGE_SIZE) {\n      console.warn(`Data for key \"${key}\" exceeds size limit:`, (jsonString.length / 1024 / 1024).toFixed(2) + 'MB');\n      return false;\n    }\n\n    // Save to localStorage\n    localStorage.setItem(key, jsonString);\n    return true;\n  } catch (error) {\n    console.error(`Error saving data for key \"${key}\":`, error);\n    return false;\n  }\n};\n\n/**\r\n * Safely get data from localStorage\r\n * @param key The localStorage key\r\n * @param defaultValue Default value to return if item not found or parsing fails\r\n * @returns The parsed data or defaultValue\r\n */\nexport const safeGetItem = (key, defaultValue) => {\n  try {\n    const item = localStorage.getItem(key);\n    if (!item) return defaultValue;\n    return JSON.parse(item);\n  } catch (error) {\n    console.error(`Error retrieving data for key \"${key}\":`, error);\n    return defaultValue;\n  }\n};\n\n/**\r\n * Safely remove data from localStorage\r\n * @param key The localStorage key\r\n * @returns true if removal was successful, false otherwise\r\n */\nexport const safeRemoveItem = key => {\n  try {\n    localStorage.removeItem(key);\n    return true;\n  } catch (error) {\n    console.error(`Error removing data for key \"${key}\":`, error);\n    return false;\n  }\n};\n\n/**\r\n * Check if browser storage is available\r\n * @returns true if localStorage is available, false otherwise\r\n */\nexport const isStorageAvailable = () => {\n  try {\n    const testKey = '__storage_test__';\n    localStorage.setItem(testKey, testKey);\n    const result = localStorage.getItem(testKey) === testKey;\n    localStorage.removeItem(testKey);\n    return result;\n  } catch (error) {\n    return false;\n  }\n};\n\n/**\r\n * Estimate storage usage\r\n * @returns Object with usage information\r\n */\nexport const getStorageUsage = () => {\n  try {\n    let totalSize = 0;\n\n    // Loop through all localStorage items to calculate total size\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key) {\n        const value = localStorage.getItem(key) || '';\n        totalSize += key.length + value.length;\n      }\n    }\n\n    // Convert to MB for readability\n    const used = totalSize / (1024 * 1024);\n    const available = MAX_STORAGE_SIZE / (1024 * 1024);\n    const usedPercent = totalSize / MAX_STORAGE_SIZE * 100;\n    return {\n      used,\n      available,\n      usedPercent\n    };\n  } catch (error) {\n    console.error('Error calculating storage usage:', error);\n    return {\n      used: 0,\n      available: MAX_STORAGE_SIZE / (1024 * 1024),\n      usedPercent: 0\n    };\n  }\n};\n\n/**\r\n * Clean up old or non-critical data to free up space\r\n * @param criticalKeys Array of keys that should not be removed\r\n * @returns true if cleanup was successful, false otherwise\r\n */\nexport const cleanupStorage = (criticalKeys = []) => {\n  try {\n    // For now, just remove any keys not in the criticalKeys list\n    const keysToKeep = new Set(criticalKeys);\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && !keysToKeep.has(key)) {\n        // Only remove keys that aren't in our critical list\n        localStorage.removeItem(key);\n      }\n    }\n    return true;\n  } catch (error) {\n    console.error('Error cleaning up storage:', error);\n    return false;\n  }\n};","map":{"version":3,"names":["MAX_STORAGE_SIZE","safeSetItem","key","data","jsonString","JSON","stringify","length","console","warn","toFixed","localStorage","setItem","error","safeGetItem","defaultValue","item","getItem","parse","safeRemoveItem","removeItem","isStorageAvailable","testKey","result","getStorageUsage","totalSize","i","value","used","available","usedPercent","cleanupStorage","criticalKeys","keysToKeep","Set","has"],"sources":["C:/Users/Domin/Desktop/coding/WaveringTides-master/frontend/src/utils/storageUtils.ts"],"sourcesContent":["/**\r\n * Storage utilities for safely handling localStorage operations\r\n */\r\n\r\n// Maximum size for localStorage items (5MB is a safe limit for most browsers)\r\nconst MAX_STORAGE_SIZE = 5 * 1024 * 1024; // 5MB in bytes\r\n\r\n/**\r\n * Safely save data to localStorage with size checking\r\n * @param key The localStorage key\r\n * @param data The data to save\r\n * @returns true if save was successful, false otherwise\r\n */\r\nexport const safeSetItem = (key: string, data: any): boolean => {\r\n  try {\r\n    // Convert data to JSON string\r\n    const jsonString = typeof data === 'string' ? data : JSON.stringify(data);\r\n    \r\n    // Check size\r\n    if (jsonString.length > MAX_STORAGE_SIZE) {\r\n      console.warn(`Data for key \"${key}\" exceeds size limit:`, \r\n                  (jsonString.length / 1024 / 1024).toFixed(2) + 'MB');\r\n      return false;\r\n    }\r\n    \r\n    // Save to localStorage\r\n    localStorage.setItem(key, jsonString);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`Error saving data for key \"${key}\":`, error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Safely get data from localStorage\r\n * @param key The localStorage key\r\n * @param defaultValue Default value to return if item not found or parsing fails\r\n * @returns The parsed data or defaultValue\r\n */\r\nexport const safeGetItem = <T>(key: string, defaultValue: T): T => {\r\n  try {\r\n    const item = localStorage.getItem(key);\r\n    if (!item) return defaultValue;\r\n    \r\n    return JSON.parse(item) as T;\r\n  } catch (error) {\r\n    console.error(`Error retrieving data for key \"${key}\":`, error);\r\n    return defaultValue;\r\n  }\r\n};\r\n\r\n/**\r\n * Safely remove data from localStorage\r\n * @param key The localStorage key\r\n * @returns true if removal was successful, false otherwise\r\n */\r\nexport const safeRemoveItem = (key: string): boolean => {\r\n  try {\r\n    localStorage.removeItem(key);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`Error removing data for key \"${key}\":`, error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Check if browser storage is available\r\n * @returns true if localStorage is available, false otherwise\r\n */\r\nexport const isStorageAvailable = (): boolean => {\r\n  try {\r\n    const testKey = '__storage_test__';\r\n    localStorage.setItem(testKey, testKey);\r\n    const result = localStorage.getItem(testKey) === testKey;\r\n    localStorage.removeItem(testKey);\r\n    return result;\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Estimate storage usage\r\n * @returns Object with usage information\r\n */\r\nexport const getStorageUsage = (): { used: number, available: number, usedPercent: number } => {\r\n  try {\r\n    let totalSize = 0;\r\n    \r\n    // Loop through all localStorage items to calculate total size\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key) {\r\n        const value = localStorage.getItem(key) || '';\r\n        totalSize += key.length + value.length;\r\n      }\r\n    }\r\n    \r\n    // Convert to MB for readability\r\n    const used = totalSize / (1024 * 1024);\r\n    const available = MAX_STORAGE_SIZE / (1024 * 1024);\r\n    const usedPercent = (totalSize / MAX_STORAGE_SIZE) * 100;\r\n    \r\n    return { used, available, usedPercent };\r\n  } catch (error) {\r\n    console.error('Error calculating storage usage:', error);\r\n    return { used: 0, available: MAX_STORAGE_SIZE / (1024 * 1024), usedPercent: 0 };\r\n  }\r\n};\r\n\r\n/**\r\n * Clean up old or non-critical data to free up space\r\n * @param criticalKeys Array of keys that should not be removed\r\n * @returns true if cleanup was successful, false otherwise\r\n */\r\nexport const cleanupStorage = (criticalKeys: string[] = []): boolean => {\r\n  try {\r\n    // For now, just remove any keys not in the criticalKeys list\r\n    const keysToKeep = new Set(criticalKeys);\r\n    \r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && !keysToKeep.has(key)) {\r\n        // Only remove keys that aren't in our critical list\r\n        localStorage.removeItem(key);\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error cleaning up storage:', error);\r\n    return false;\r\n  }\r\n}; "],"mappings":"AAAA;AACA;AACA;;AAEA;AACA,MAAMA,gBAAgB,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAGA,CAACC,GAAW,EAAEC,IAAS,KAAc;EAC9D,IAAI;IACF;IACA,MAAMC,UAAU,GAAG,OAAOD,IAAI,KAAK,QAAQ,GAAGA,IAAI,GAAGE,IAAI,CAACC,SAAS,CAACH,IAAI,CAAC;;IAEzE;IACA,IAAIC,UAAU,CAACG,MAAM,GAAGP,gBAAgB,EAAE;MACxCQ,OAAO,CAACC,IAAI,CAAC,iBAAiBP,GAAG,uBAAuB,EAC5C,CAACE,UAAU,CAACG,MAAM,GAAG,IAAI,GAAG,IAAI,EAAEG,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;MAChE,OAAO,KAAK;IACd;;IAEA;IACAC,YAAY,CAACC,OAAO,CAACV,GAAG,EAAEE,UAAU,CAAC;IACrC,OAAO,IAAI;EACb,CAAC,CAAC,OAAOS,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,8BAA8BX,GAAG,IAAI,EAAEW,KAAK,CAAC;IAC3D,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAGA,CAAIZ,GAAW,EAAEa,YAAe,KAAQ;EACjE,IAAI;IACF,MAAMC,IAAI,GAAGL,YAAY,CAACM,OAAO,CAACf,GAAG,CAAC;IACtC,IAAI,CAACc,IAAI,EAAE,OAAOD,YAAY;IAE9B,OAAOV,IAAI,CAACa,KAAK,CAACF,IAAI,CAAC;EACzB,CAAC,CAAC,OAAOH,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,kCAAkCX,GAAG,IAAI,EAAEW,KAAK,CAAC;IAC/D,OAAOE,YAAY;EACrB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,cAAc,GAAIjB,GAAW,IAAc;EACtD,IAAI;IACFS,YAAY,CAACS,UAAU,CAAClB,GAAG,CAAC;IAC5B,OAAO,IAAI;EACb,CAAC,CAAC,OAAOW,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,gCAAgCX,GAAG,IAAI,EAAEW,KAAK,CAAC;IAC7D,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMQ,kBAAkB,GAAGA,CAAA,KAAe;EAC/C,IAAI;IACF,MAAMC,OAAO,GAAG,kBAAkB;IAClCX,YAAY,CAACC,OAAO,CAACU,OAAO,EAAEA,OAAO,CAAC;IACtC,MAAMC,MAAM,GAAGZ,YAAY,CAACM,OAAO,CAACK,OAAO,CAAC,KAAKA,OAAO;IACxDX,YAAY,CAACS,UAAU,CAACE,OAAO,CAAC;IAChC,OAAOC,MAAM;EACf,CAAC,CAAC,OAAOV,KAAK,EAAE;IACd,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMW,eAAe,GAAGA,CAAA,KAAgE;EAC7F,IAAI;IACF,IAAIC,SAAS,GAAG,CAAC;;IAEjB;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,YAAY,CAACJ,MAAM,EAAEmB,CAAC,EAAE,EAAE;MAC5C,MAAMxB,GAAG,GAAGS,YAAY,CAACT,GAAG,CAACwB,CAAC,CAAC;MAC/B,IAAIxB,GAAG,EAAE;QACP,MAAMyB,KAAK,GAAGhB,YAAY,CAACM,OAAO,CAACf,GAAG,CAAC,IAAI,EAAE;QAC7CuB,SAAS,IAAIvB,GAAG,CAACK,MAAM,GAAGoB,KAAK,CAACpB,MAAM;MACxC;IACF;;IAEA;IACA,MAAMqB,IAAI,GAAGH,SAAS,IAAI,IAAI,GAAG,IAAI,CAAC;IACtC,MAAMI,SAAS,GAAG7B,gBAAgB,IAAI,IAAI,GAAG,IAAI,CAAC;IAClD,MAAM8B,WAAW,GAAIL,SAAS,GAAGzB,gBAAgB,GAAI,GAAG;IAExD,OAAO;MAAE4B,IAAI;MAAEC,SAAS;MAAEC;IAAY,CAAC;EACzC,CAAC,CAAC,OAAOjB,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;IACxD,OAAO;MAAEe,IAAI,EAAE,CAAC;MAAEC,SAAS,EAAE7B,gBAAgB,IAAI,IAAI,GAAG,IAAI,CAAC;MAAE8B,WAAW,EAAE;IAAE,CAAC;EACjF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAGA,CAACC,YAAsB,GAAG,EAAE,KAAc;EACtE,IAAI;IACF;IACA,MAAMC,UAAU,GAAG,IAAIC,GAAG,CAACF,YAAY,CAAC;IAExC,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,YAAY,CAACJ,MAAM,EAAEmB,CAAC,EAAE,EAAE;MAC5C,MAAMxB,GAAG,GAAGS,YAAY,CAACT,GAAG,CAACwB,CAAC,CAAC;MAC/B,IAAIxB,GAAG,IAAI,CAAC+B,UAAU,CAACE,GAAG,CAACjC,GAAG,CAAC,EAAE;QAC/B;QACAS,YAAY,CAACS,UAAU,CAAClB,GAAG,CAAC;MAC9B;IACF;IAEA,OAAO,IAAI;EACb,CAAC,CAAC,OAAOW,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClD,OAAO,KAAK;EACd;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}