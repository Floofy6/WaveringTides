{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useInventory } from './useInventory';\nimport { SKILL_IDS, ENEMIES, ITEM_IDS, ITEMS } from '../constants';\n\n/**\n * useCombat hook - Manages combat-related state and operations\n */\nexport const useCombat = () => {\n  _s();\n  const {\n    gameState,\n    updateGameState\n  } = useGameContext();\n  const {\n    addItem\n  } = useInventory();\n\n  // Use enemies from constants rather than mock data\n  const [enemies] = useState(Object.values(ENEMIES));\n\n  // Local state for combat\n  const [currentEnemy, setCurrentEnemy] = useState(null);\n  const [combatLog, setCombatLog] = useState([]);\n  const [combatInterval, setCombatInterval] = useState(null);\n  const [combatTick, setCombatTick] = useState(0); // Used to trigger combat animations\n\n  // Track separate timers for player and enemy attacks\n  const [lastPlayerAttack, setLastPlayerAttack] = useState(0);\n  const [lastEnemyAttack, setLastEnemyAttack] = useState(0);\n  const [playerAttackTimer, setPlayerAttackTimer] = useState(null);\n  const [enemyAttackTimer, setEnemyAttackTimer] = useState(null);\n\n  // Compute player stats from the game state\n  const getPlayerStats = useCallback(() => {\n    var _gameState$player$ski, _gameState$player$ski2, _gameState$player$ski3, _gameState$player$ski4, _gameState$player$ski5, _gameState$player$equ, _gameState$player$equ2, _gameState$player$equ3, _gameState$player$equ4, _gameState$player$equ5, _gameState$player$equ6;\n    if (!(gameState !== null && gameState !== void 0 && gameState.player)) return {\n      attack: 1,\n      strength: 1,\n      defense: 1,\n      health: 10,\n      maxHealth: 10\n    };\n    const attack = ((_gameState$player$ski = gameState.player.skills[SKILL_IDS.ATTACK]) === null || _gameState$player$ski === void 0 ? void 0 : _gameState$player$ski.level) || 1;\n    const strength = ((_gameState$player$ski2 = gameState.player.skills[SKILL_IDS.STRENGTH]) === null || _gameState$player$ski2 === void 0 ? void 0 : _gameState$player$ski2.level) || 1;\n    const defense = ((_gameState$player$ski3 = gameState.player.skills[SKILL_IDS.DEFENCE]) === null || _gameState$player$ski3 === void 0 ? void 0 : _gameState$player$ski3.level) || 1;\n\n    // Health is stored as XP in hitpoints skill\n    // If not defined or <= 0, default to 10 (minimum health)\n    const health = Math.max(10, ((_gameState$player$ski4 = gameState.player.skills[SKILL_IDS.HITPOINTS]) === null || _gameState$player$ski4 === void 0 ? void 0 : _gameState$player$ski4.xp) || 10);\n\n    // Max health calculation: 10 base + 4 per hitpoints level\n    const hitpointsLevel = ((_gameState$player$ski5 = gameState.player.skills[SKILL_IDS.HITPOINTS]) === null || _gameState$player$ski5 === void 0 ? void 0 : _gameState$player$ski5.level) || 1;\n    const maxHealth = 10 + hitpointsLevel * 4;\n\n    // Add equipment bonuses\n    const attackBonus = ((_gameState$player$equ = gameState.player.equipment.weapon) === null || _gameState$player$equ === void 0 ? void 0 : (_gameState$player$equ2 = _gameState$player$equ.stats) === null || _gameState$player$equ2 === void 0 ? void 0 : _gameState$player$equ2.attackBonus) || 0;\n    const strengthBonus = ((_gameState$player$equ3 = gameState.player.equipment.weapon) === null || _gameState$player$equ3 === void 0 ? void 0 : (_gameState$player$equ4 = _gameState$player$equ3.stats) === null || _gameState$player$equ4 === void 0 ? void 0 : _gameState$player$equ4.strengthBonus) || 0;\n    const defenseBonus = ((_gameState$player$equ5 = gameState.player.equipment.armor) === null || _gameState$player$equ5 === void 0 ? void 0 : (_gameState$player$equ6 = _gameState$player$equ5.stats) === null || _gameState$player$equ6 === void 0 ? void 0 : _gameState$player$equ6.defenseBonus) || 0;\n    return {\n      attack: attack + attackBonus,\n      strength: strength + strengthBonus,\n      defense: defense + defenseBonus,\n      health,\n      maxHealth\n    };\n  }, [gameState]);\n\n  // Calculate combat stats\n  const playerStats = getPlayerStats();\n\n  /**\n   * Add a message to the combat log\n   */\n  const addLogMessage = useCallback(message => {\n    setCombatLog(prevLog => [message, ...prevLog].slice(0, 50)); // Keep last 50 messages\n  }, []);\n\n  /**\n   * Calculate damage based on attacker and defender stats\n   * Improved formula for more balanced combat\n   */\n  const calculateDamage = useCallback((attackerAttack, attackerStrength, defenderDefense) => {\n    try {\n      // Calculate hit chance - improved formula\n      // Higher attack vs defense = better chance to hit\n      const effectiveAttack = attackerAttack + 10; // Increased base value for better early game hit chance\n      const hitChance = Math.min(0.95, Math.max(0.2, effectiveAttack / (effectiveAttack + defenderDefense * 0.7)));\n      const didHit = Math.random() < hitChance;\n      if (!didHit) return 0;\n\n      // Base damage calculation - improved for more consistent damage\n      // Higher strength = higher potential damage\n      const maxHit = Math.floor(1 + attackerStrength * 0.15); // Increased base damage multiplier\n      const damageVariation = 0.7; // 70% variation to make damage more consistent\n      const minDamage = Math.max(1, Math.floor(maxHit * (1 - damageVariation)));\n      const damage = Math.floor(minDamage + Math.random() * (maxHit - minDamage + 1));\n      return Math.max(1, damage); // Always hit at least 1 if the attack lands\n    } catch (error) {\n      console.error('Error calculating damage:', error);\n      return 1; // Fallback to minimum damage on error\n    }\n  }, []);\n\n  /**\n   * Calculate XP required for next level using OSRS-inspired formula\n   */\n  const calculateXpForNextLevel = useCallback(level => {\n    return Math.floor(100 * level ** 1.5);\n  }, []);\n\n  /**\n   * Handle enemy defeat and loot\n   */\n  const handleEnemyDefeated = useCallback(enemy => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    addLogMessage(`You defeated the ${enemy.name}!`);\n\n    // Process loot drops\n    const lootMessages = [];\n    const lootItems = [];\n    enemy.lootTable.forEach(loot => {\n      if (Math.random() <= loot.chance) {\n        var _ITEMS$loot$itemId, _ITEMS$loot$itemId2, _ITEMS$loot$itemId3, _ITEMS$loot$itemId4;\n        lootMessages.push(`You received ${loot.quantity} ${loot.itemId}!`);\n\n        // Use the item constants directly\n        const itemName = ((_ITEMS$loot$itemId = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId === void 0 ? void 0 : _ITEMS$loot$itemId.name) || loot.itemId;\n        lootItems.push({\n          id: loot.itemId,\n          name: itemName,\n          quantity: loot.quantity,\n          type: ((_ITEMS$loot$itemId2 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId2 === void 0 ? void 0 : _ITEMS$loot$itemId2.type) || 'resource',\n          sellPrice: ((_ITEMS$loot$itemId3 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId3 === void 0 ? void 0 : _ITEMS$loot$itemId3.sellPrice) || 5,\n          stats: (_ITEMS$loot$itemId4 = ITEMS[loot.itemId]) === null || _ITEMS$loot$itemId4 === void 0 ? void 0 : _ITEMS$loot$itemId4.stats\n        });\n      }\n    });\n\n    // Award gold\n    const goldAmount = Math.floor(Math.random() * (enemy.maxHealth / 2)) + 5;\n    lootMessages.push(`You found ${goldAmount} gold!`);\n\n    // Update player state with loot and gold\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      const newState = JSON.parse(JSON.stringify(prevState));\n\n      // Add gold\n      newState.player.gold += goldAmount;\n\n      // Add items to inventory - directly update inventory in the state\n      lootItems.forEach(item => {\n        if (newState.player.inventory[item.id]) {\n          newState.player.inventory[item.id].quantity += item.quantity;\n        } else {\n          newState.player.inventory[item.id] = item;\n        }\n      });\n\n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      return newState;\n    });\n\n    // Display loot messages\n    lootMessages.forEach(msg => addLogMessage(msg));\n\n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n\n  /**\n   * Handle player defeat\n   */\n  const handlePlayerDefeated = useCallback(() => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    addLogMessage('You have been defeated!');\n\n    // Update player state - reset combat and restore some health\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      const newState = JSON.parse(JSON.stringify(prevState));\n\n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n\n      // Restore some hitpoints - 25% of max health\n      if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n        const hitpointsLevel = newState.player.skills[SKILL_IDS.HITPOINTS].level || 1;\n        const maxHealth = 10 + hitpointsLevel * 4;\n        newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.floor(maxHealth * 0.25);\n        addLogMessage('You wake up with some health restored.');\n      }\n      return newState;\n    });\n\n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n\n  /**\n   * Calculate player's attack speed in milliseconds\n   * Lower numbers mean faster attacks\n   */\n  const getPlayerAttackSpeed = useCallback(() => {\n    var _gameState$player, _gameState$player$equ7, _gameState$player2, _gameState$player2$sk;\n    // Base attack speed\n    let attackSpeed = 2000; // Base: 2 seconds between attacks\n\n    // Factor in weapon type\n    if (gameState !== null && gameState !== void 0 && (_gameState$player = gameState.player) !== null && _gameState$player !== void 0 && (_gameState$player$equ7 = _gameState$player.equipment) !== null && _gameState$player$equ7 !== void 0 && _gameState$player$equ7.weapon) {\n      var _weapon$stats;\n      const weapon = gameState.player.equipment.weapon;\n\n      // Different weapons have different speeds\n      if (weapon.id === ITEM_IDS.BRONZE_SWORD) {\n        attackSpeed = 1800; // Swords are faster\n      }\n\n      // Weapon quality can further improve speed\n      if ((_weapon$stats = weapon.stats) !== null && _weapon$stats !== void 0 && _weapon$stats.attackBonus) {\n        // Each point of attack bonus reduces attack time by 50ms\n        attackSpeed -= weapon.stats.attackBonus * 50;\n      }\n    }\n\n    // Factor in skills - higher attack level = faster attacks\n    const attackLevel = (gameState === null || gameState === void 0 ? void 0 : (_gameState$player2 = gameState.player) === null || _gameState$player2 === void 0 ? void 0 : (_gameState$player2$sk = _gameState$player2.skills[SKILL_IDS.ATTACK]) === null || _gameState$player2$sk === void 0 ? void 0 : _gameState$player2$sk.level) || 1;\n    // Each level above 1 reduces attack time by 20ms\n    attackSpeed -= (attackLevel - 1) * 20;\n\n    // Ensure attack speed doesn't go below minimum (very fast)\n    return Math.max(800, attackSpeed);\n  }, [gameState]);\n\n  /**\n   * Process player attack\n   */\n  const processPlayerAttack = useCallback(() => {\n    if (!currentEnemy || !(gameState !== null && gameState !== void 0 && gameState.player)) return;\n\n    // Get current player stats\n    const stats = getPlayerStats();\n\n    // Player attacks enemy\n    const playerDamage = calculateDamage(stats.attack, stats.strength, currentEnemy.defense);\n    if (playerDamage > 0) {\n      // Update enemy health\n      const newEnemyHealth = Math.max(0, currentEnemy.health - playerDamage);\n      setCurrentEnemy(prev => prev ? {\n        ...prev,\n        health: newEnemyHealth\n      } : null);\n\n      // Add attack message to combat log\n      addLogMessage(`You hit the ${currentEnemy.name} for ${playerDamage} damage!`);\n\n      // Trigger animation\n      setCombatTick(prev => prev + 1);\n\n      // Award combat XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        const newState = JSON.parse(JSON.stringify(prevState));\n\n        // Add XP to Attack and Strength\n        if (newState.player.skills[SKILL_IDS.ATTACK]) {\n          const attackXp = playerDamage * 4;\n          const currentAttackXp = newState.player.skills[SKILL_IDS.ATTACK].xp || 0;\n          newState.player.skills[SKILL_IDS.ATTACK].xp = currentAttackXp + attackXp;\n\n          // Check for level ups\n          const attackLevel = newState.player.skills[SKILL_IDS.ATTACK].level;\n          const xpForNextLevel = calculateXpForNextLevel(attackLevel);\n          if (newState.player.skills[SKILL_IDS.ATTACK].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.ATTACK].level += 1;\n            addLogMessage(`Congratulations! Your Attack level is now ${newState.player.skills[SKILL_IDS.ATTACK].level}`);\n          }\n        }\n        if (newState.player.skills[SKILL_IDS.STRENGTH]) {\n          const strengthXp = playerDamage * 4;\n          const currentStrengthXp = newState.player.skills[SKILL_IDS.STRENGTH].xp || 0;\n          newState.player.skills[SKILL_IDS.STRENGTH].xp = currentStrengthXp + strengthXp;\n\n          // Check for level ups\n          const strengthLevel = newState.player.skills[SKILL_IDS.STRENGTH].level;\n          const xpForNextLevel = calculateXpForNextLevel(strengthLevel);\n          if (newState.player.skills[SKILL_IDS.STRENGTH].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.STRENGTH].level += 1;\n            addLogMessage(`Congratulations! Your Strength level is now ${newState.player.skills[SKILL_IDS.STRENGTH].level}`);\n          }\n        }\n        return newState;\n      });\n\n      // Check if enemy is defeated\n      if (newEnemyHealth <= 0) {\n        handleEnemyDefeated(currentEnemy);\n        return;\n      }\n    } else {\n      addLogMessage(`Your attack missed the ${currentEnemy.name}!`);\n      // Still trigger animation for the miss\n      setCombatTick(prev => prev + 1);\n    }\n\n    // Schedule next player attack\n    setLastPlayerAttack(Date.now());\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handleEnemyDefeated]);\n\n  /**\n   * Process enemy attack\n   */\n  const processEnemyAttack = useCallback(() => {\n    if (!currentEnemy || !(gameState !== null && gameState !== void 0 && gameState.player)) return;\n    const stats = getPlayerStats();\n\n    // Enemy attacks player\n    const enemyDamage = calculateDamage(currentEnemy.attack, currentEnemy.attack, stats.defense);\n    if (enemyDamage > 0) {\n      addLogMessage(`The ${currentEnemy.name} hits you for ${enemyDamage} damage!`);\n\n      // Trigger animation\n      setCombatTick(prev => prev + 2); // Use a different number to trigger a different animation\n\n      // Update player health and award Defense XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        const newState = JSON.parse(JSON.stringify(prevState));\n\n        // Add XP to Defense (positive XP for being hit)\n        if (newState.player.skills[SKILL_IDS.DEFENCE]) {\n          const defenseXp = enemyDamage * 4;\n          const currentDefenseXp = newState.player.skills[SKILL_IDS.DEFENCE].xp || 0;\n          newState.player.skills[SKILL_IDS.DEFENCE].xp = currentDefenseXp + defenseXp;\n\n          // Check for level ups\n          const defenseLevel = newState.player.skills[SKILL_IDS.DEFENCE].level;\n          const xpForNextLevel = calculateXpForNextLevel(defenseLevel);\n          if (newState.player.skills[SKILL_IDS.DEFENCE].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.DEFENCE].level += 1;\n            addLogMessage(`Congratulations! Your Defense level is now ${newState.player.skills[SKILL_IDS.DEFENCE].level}`);\n          }\n        }\n\n        // Reduce Hitpoints XP (as damage)\n        if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n          const currentHitpointsXp = newState.player.skills[SKILL_IDS.HITPOINTS].xp || 10;\n          newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.max(0, currentHitpointsXp - enemyDamage);\n\n          // Check if player is defeated\n          if (newState.player.skills[SKILL_IDS.HITPOINTS].xp <= 0) {\n            handlePlayerDefeated();\n          }\n        }\n        return newState;\n      });\n    } else {\n      addLogMessage(`The ${currentEnemy.name}'s attack missed you!`);\n      // Still trigger animation for the miss\n      setCombatTick(prev => prev + 2);\n    }\n\n    // Schedule next enemy attack\n    setLastEnemyAttack(Date.now());\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handlePlayerDefeated]);\n\n  /**\n   * Process a single combat round - now manages the timing for both player and enemy attacks\n   */\n  const processCombatRound = useCallback(() => {\n    if (!currentEnemy || !(gameState !== null && gameState !== void 0 && gameState.player)) return;\n    const now = Date.now();\n    const playerSpeed = getPlayerAttackSpeed();\n    const enemySpeed = currentEnemy.attackSpeed || 2000; // Default to 2 seconds if not specified\n\n    // Check if it's time for player to attack\n    if (now - lastPlayerAttack >= playerSpeed) {\n      processPlayerAttack();\n    }\n\n    // Check if it's time for enemy to attack\n    if (now - lastEnemyAttack >= enemySpeed) {\n      processEnemyAttack();\n    }\n  }, [currentEnemy, gameState, getPlayerAttackSpeed, lastPlayerAttack, lastEnemyAttack, processPlayerAttack, processEnemyAttack]);\n\n  /**\n   * Start combat with an enemy\n   */\n  const startCombat = useCallback(enemyId => {\n    // Stop any existing combat\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    if (playerAttackTimer) {\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    if (enemyAttackTimer) {\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n\n    // Find the enemy\n    const enemy = enemies.find(e => e.id === enemyId);\n    if (!enemy) {\n      console.error(`Enemy with ID ${enemyId} not found`);\n      return;\n    }\n\n    // Clone the enemy to avoid modifying the original\n    const enemyClone = {\n      ...enemy,\n      health: enemy.maxHealth // Reset health\n    };\n    setCurrentEnemy(enemyClone);\n    setCombatLog([`Combat started with ${enemyClone.name}!`]);\n\n    // Reset attack timers\n    setLastPlayerAttack(Date.now());\n    setLastEnemyAttack(Date.now());\n\n    // Update game state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            currentEnemy: enemyClone,\n            isFighting: true\n          }\n        }\n      };\n    });\n\n    // Start with player's first attack\n    processPlayerAttack();\n\n    // Set up the enemy's first attack with appropriate delay\n    const enemyTimer = setTimeout(() => {\n      processEnemyAttack();\n    }, enemyClone.attackSpeed / 2); // Start at half the enemy's attack speed for better flow\n\n    setEnemyAttackTimer(enemyTimer);\n\n    // Start combat loop - check for attacks every 100ms\n    const interval = setInterval(processCombatRound, 100);\n    setCombatInterval(interval);\n    return () => {\n      clearInterval(interval);\n      clearTimeout(enemyTimer);\n    };\n  }, [enemies, combatInterval, playerAttackTimer, enemyAttackTimer, updateGameState, processCombatRound, processPlayerAttack, processEnemyAttack]);\n\n  /**\n   * Flee from combat\n   */\n  const fleeCombat = useCallback(() => {\n    if (!currentEnemy) return;\n\n    // Higher defense gives better flee chance\n    const playerDefense = playerStats.defense;\n    const enemyAttack = currentEnemy.attack;\n    const baseFleeProbability = 0.5; // 50% base chance\n\n    // Defense helps flee, enemy attack makes it harder\n    const fleeChance = Math.min(0.95, Math.max(0.3, baseFleeProbability + (playerDefense - enemyAttack) * 0.05));\n    if (Math.random() <= fleeChance) {\n      addLogMessage('You successfully fled from combat!');\n\n      // Stop combat loop\n      if (combatInterval) {\n        clearInterval(combatInterval);\n        setCombatInterval(null);\n      }\n\n      // Stop attack timers\n      if (playerAttackTimer) {\n        clearTimeout(playerAttackTimer);\n        setPlayerAttackTimer(null);\n      }\n      if (enemyAttackTimer) {\n        clearTimeout(enemyAttackTimer);\n        setEnemyAttackTimer(null);\n      }\n\n      // Update player state\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        return {\n          ...prevState,\n          player: {\n            ...prevState.player,\n            combat: {\n              isFighting: false,\n              currentEnemy: undefined\n            }\n          }\n        };\n      });\n\n      // Reset current enemy\n      setCurrentEnemy(null);\n    } else {\n      addLogMessage('You failed to flee!');\n\n      // Enemy gets a free attack\n      processEnemyAttack();\n    }\n  }, [currentEnemy, playerStats, combatInterval, playerAttackTimer, enemyAttackTimer, addLogMessage, updateGameState, processEnemyAttack]);\n\n  // Clean up interval and timers on unmount\n  useEffect(() => {\n    return () => {\n      if (combatInterval) {\n        clearInterval(combatInterval);\n      }\n      if (playerAttackTimer) {\n        clearTimeout(playerAttackTimer);\n      }\n      if (enemyAttackTimer) {\n        clearTimeout(enemyAttackTimer);\n      }\n    };\n  }, [combatInterval, playerAttackTimer, enemyAttackTimer]);\n  return {\n    enemies,\n    currentEnemy,\n    isFighting: !!currentEnemy,\n    playerStats,\n    combatLog,\n    combatTick,\n    // Expose combat tick for animations\n    startCombat,\n    fleeCombat,\n    processCombatRound // Exposed for manual combat if needed\n  };\n};\n_s(useCombat, \"5Guo9otxv8630QhusW5aP5WK2zs=\", false, function () {\n  return [useGameContext, useInventory];\n});","map":{"version":3,"names":["useState","useCallback","useEffect","useGameContext","useInventory","SKILL_IDS","ENEMIES","ITEM_IDS","ITEMS","useCombat","_s","gameState","updateGameState","addItem","enemies","Object","values","currentEnemy","setCurrentEnemy","combatLog","setCombatLog","combatInterval","setCombatInterval","combatTick","setCombatTick","lastPlayerAttack","setLastPlayerAttack","lastEnemyAttack","setLastEnemyAttack","playerAttackTimer","setPlayerAttackTimer","enemyAttackTimer","setEnemyAttackTimer","getPlayerStats","_gameState$player$ski","_gameState$player$ski2","_gameState$player$ski3","_gameState$player$ski4","_gameState$player$ski5","_gameState$player$equ","_gameState$player$equ2","_gameState$player$equ3","_gameState$player$equ4","_gameState$player$equ5","_gameState$player$equ6","player","attack","strength","defense","health","maxHealth","skills","ATTACK","level","STRENGTH","DEFENCE","Math","max","HITPOINTS","xp","hitpointsLevel","attackBonus","equipment","weapon","stats","strengthBonus","defenseBonus","armor","playerStats","addLogMessage","message","prevLog","slice","calculateDamage","attackerAttack","attackerStrength","defenderDefense","effectiveAttack","hitChance","min","didHit","random","maxHit","floor","damageVariation","minDamage","damage","error","console","calculateXpForNextLevel","handleEnemyDefeated","enemy","clearInterval","name","lootMessages","lootItems","lootTable","forEach","loot","chance","_ITEMS$loot$itemId","_ITEMS$loot$itemId2","_ITEMS$loot$itemId3","_ITEMS$loot$itemId4","push","quantity","itemId","itemName","id","type","sellPrice","goldAmount","prevState","newState","JSON","parse","stringify","gold","item","inventory","combat","isFighting","undefined","msg","handlePlayerDefeated","getPlayerAttackSpeed","_gameState$player","_gameState$player$equ7","_gameState$player2","_gameState$player2$sk","attackSpeed","_weapon$stats","BRONZE_SWORD","attackLevel","processPlayerAttack","playerDamage","newEnemyHealth","prev","attackXp","currentAttackXp","xpForNextLevel","strengthXp","currentStrengthXp","strengthLevel","Date","now","processEnemyAttack","enemyDamage","defenseXp","currentDefenseXp","defenseLevel","currentHitpointsXp","processCombatRound","playerSpeed","enemySpeed","startCombat","enemyId","clearTimeout","find","e","enemyClone","enemyTimer","setTimeout","interval","setInterval","fleeCombat","playerDefense","enemyAttack","baseFleeProbability","fleeChance"],"sources":["C:/Users/Domin/Desktop/coding/WaveringTides-master/frontend/src/hooks/useCombat.ts"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport { useGameContext } from '../context/GameContext';\nimport { useInventory } from './useInventory';\nimport { Enemy } from '../types';\nimport { SKILL_IDS, ENEMIES, ITEM_IDS, ITEMS } from '../constants';\n\n/**\n * useCombat hook - Manages combat-related state and operations\n */\nexport const useCombat = () => {\n  const { gameState, updateGameState } = useGameContext();\n  const { addItem } = useInventory();\n  \n  // Use enemies from constants rather than mock data\n  const [enemies] = useState<Enemy[]>(Object.values(ENEMIES));\n  \n  // Local state for combat\n  const [currentEnemy, setCurrentEnemy] = useState<Enemy | null>(null);\n  const [combatLog, setCombatLog] = useState<string[]>([]);\n  const [combatInterval, setCombatInterval] = useState<NodeJS.Timeout | null>(null);\n  const [combatTick, setCombatTick] = useState<number>(0); // Used to trigger combat animations\n  \n  // Track separate timers for player and enemy attacks\n  const [lastPlayerAttack, setLastPlayerAttack] = useState<number>(0);\n  const [lastEnemyAttack, setLastEnemyAttack] = useState<number>(0);\n  const [playerAttackTimer, setPlayerAttackTimer] = useState<NodeJS.Timeout | null>(null);\n  const [enemyAttackTimer, setEnemyAttackTimer] = useState<NodeJS.Timeout | null>(null);\n  \n  // Compute player stats from the game state\n  const getPlayerStats = useCallback(() => {\n    if (!gameState?.player) return { attack: 1, strength: 1, defense: 1, health: 10, maxHealth: 10 };\n    \n    const attack = gameState.player.skills[SKILL_IDS.ATTACK]?.level || 1;\n    const strength = gameState.player.skills[SKILL_IDS.STRENGTH]?.level || 1;\n    const defense = gameState.player.skills[SKILL_IDS.DEFENCE]?.level || 1;\n    \n    // Health is stored as XP in hitpoints skill\n    // If not defined or <= 0, default to 10 (minimum health)\n    const health = Math.max(10, gameState.player.skills[SKILL_IDS.HITPOINTS]?.xp || 10);\n    \n    // Max health calculation: 10 base + 4 per hitpoints level\n    const hitpointsLevel = gameState.player.skills[SKILL_IDS.HITPOINTS]?.level || 1;\n    const maxHealth = 10 + (hitpointsLevel * 4);\n    \n    // Add equipment bonuses\n    const attackBonus = gameState.player.equipment.weapon?.stats?.attackBonus || 0;\n    const strengthBonus = gameState.player.equipment.weapon?.stats?.strengthBonus || 0;\n    const defenseBonus = gameState.player.equipment.armor?.stats?.defenseBonus || 0;\n    \n    return {\n      attack: attack + attackBonus,\n      strength: strength + strengthBonus,\n      defense: defense + defenseBonus,\n      health,\n      maxHealth\n    };\n  }, [gameState]);\n  \n  // Calculate combat stats\n  const playerStats = getPlayerStats();\n  \n  /**\n   * Add a message to the combat log\n   */\n  const addLogMessage = useCallback((message: string) => {\n    setCombatLog(prevLog => [message, ...prevLog].slice(0, 50)); // Keep last 50 messages\n  }, []);\n  \n  /**\n   * Calculate damage based on attacker and defender stats\n   * Improved formula for more balanced combat\n   */\n  const calculateDamage = useCallback((attackerAttack: number, attackerStrength: number, defenderDefense: number) => {\n    try {\n      // Calculate hit chance - improved formula\n      // Higher attack vs defense = better chance to hit\n      const effectiveAttack = attackerAttack + 10; // Increased base value for better early game hit chance\n      const hitChance = Math.min(0.95, Math.max(0.2, effectiveAttack / (effectiveAttack + defenderDefense * 0.7)));\n      const didHit = Math.random() < hitChance;\n      \n      if (!didHit) return 0;\n      \n      // Base damage calculation - improved for more consistent damage\n      // Higher strength = higher potential damage\n      const maxHit = Math.floor(1 + (attackerStrength * 0.15)); // Increased base damage multiplier\n      const damageVariation = 0.7; // 70% variation to make damage more consistent\n      const minDamage = Math.max(1, Math.floor(maxHit * (1 - damageVariation)));\n      const damage = Math.floor(minDamage + Math.random() * (maxHit - minDamage + 1));\n      \n      return Math.max(1, damage); // Always hit at least 1 if the attack lands\n    } catch (error) {\n      console.error('Error calculating damage:', error);\n      return 1; // Fallback to minimum damage on error\n    }\n  }, []);\n  \n  /**\n   * Calculate XP required for next level using OSRS-inspired formula\n   */\n  const calculateXpForNextLevel = useCallback((level: number): number => {\n    return Math.floor(100 * (level ** 1.5));\n  }, []);\n  \n  /**\n   * Handle enemy defeat and loot\n   */\n  const handleEnemyDefeated = useCallback((enemy: Enemy) => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    addLogMessage(`You defeated the ${enemy.name}!`);\n    \n    // Process loot drops\n    const lootMessages: string[] = [];\n    const lootItems: any[] = [];\n    \n    enemy.lootTable.forEach(loot => {\n      if (Math.random() <= loot.chance) {\n        lootMessages.push(`You received ${loot.quantity} ${loot.itemId}!`);\n        \n        // Use the item constants directly\n        const itemName = ITEMS[loot.itemId]?.name || loot.itemId;\n        \n        lootItems.push({\n          id: loot.itemId,\n          name: itemName,\n          quantity: loot.quantity,\n          type: ITEMS[loot.itemId]?.type || 'resource',\n          sellPrice: ITEMS[loot.itemId]?.sellPrice || 5,\n          stats: ITEMS[loot.itemId]?.stats\n        });\n      }\n    });\n    \n    // Award gold\n    const goldAmount = Math.floor(Math.random() * (enemy.maxHealth / 2)) + 5;\n    lootMessages.push(`You found ${goldAmount} gold!`);\n    \n    // Update player state with loot and gold\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      const newState = JSON.parse(JSON.stringify(prevState));\n      \n      // Add gold\n      newState.player.gold += goldAmount;\n      \n      // Add items to inventory - directly update inventory in the state\n      lootItems.forEach(item => {\n        if (newState.player.inventory[item.id]) {\n          newState.player.inventory[item.id].quantity += item.quantity;\n        } else {\n          newState.player.inventory[item.id] = item;\n        }\n      });\n      \n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      \n      return newState;\n    });\n    \n    // Display loot messages\n    lootMessages.forEach(msg => addLogMessage(msg));\n    \n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n  \n  /**\n   * Handle player defeat\n   */\n  const handlePlayerDefeated = useCallback(() => {\n    // Stop combat loop\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    addLogMessage('You have been defeated!');\n    \n    // Update player state - reset combat and restore some health\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      const newState = JSON.parse(JSON.stringify(prevState));\n      \n      // Reset combat state\n      newState.player.combat = {\n        isFighting: false,\n        currentEnemy: undefined\n      };\n      \n      // Restore some hitpoints - 25% of max health\n      if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n        const hitpointsLevel = newState.player.skills[SKILL_IDS.HITPOINTS].level || 1;\n        const maxHealth = 10 + (hitpointsLevel * 4);\n        newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.floor(maxHealth * 0.25);\n        addLogMessage('You wake up with some health restored.');\n      }\n      \n      return newState;\n    });\n    \n    // Reset current enemy\n    setCurrentEnemy(null);\n  }, [combatInterval, addLogMessage, updateGameState]);\n  \n  /**\n   * Calculate player's attack speed in milliseconds\n   * Lower numbers mean faster attacks\n   */\n  const getPlayerAttackSpeed = useCallback(() => {\n    // Base attack speed\n    let attackSpeed = 2000; // Base: 2 seconds between attacks\n    \n    // Factor in weapon type\n    if (gameState?.player?.equipment?.weapon) {\n      const weapon = gameState.player.equipment.weapon;\n      \n      // Different weapons have different speeds\n      if (weapon.id === ITEM_IDS.BRONZE_SWORD) {\n        attackSpeed = 1800; // Swords are faster\n      }\n      \n      // Weapon quality can further improve speed\n      if (weapon.stats?.attackBonus) {\n        // Each point of attack bonus reduces attack time by 50ms\n        attackSpeed -= (weapon.stats.attackBonus * 50);\n      }\n    }\n    \n    // Factor in skills - higher attack level = faster attacks\n    const attackLevel = gameState?.player?.skills[SKILL_IDS.ATTACK]?.level || 1;\n    // Each level above 1 reduces attack time by 20ms\n    attackSpeed -= (attackLevel - 1) * 20;\n    \n    // Ensure attack speed doesn't go below minimum (very fast)\n    return Math.max(800, attackSpeed);\n  }, [gameState]);\n  \n  /**\n   * Process player attack\n   */\n  const processPlayerAttack = useCallback(() => {\n    if (!currentEnemy || !gameState?.player) return;\n    \n    // Get current player stats\n    const stats = getPlayerStats();\n    \n    // Player attacks enemy\n    const playerDamage = calculateDamage(stats.attack, stats.strength, currentEnemy.defense);\n    \n    if (playerDamage > 0) {\n      // Update enemy health\n      const newEnemyHealth = Math.max(0, currentEnemy.health - playerDamage);\n      setCurrentEnemy(prev => prev ? { ...prev, health: newEnemyHealth } : null);\n      \n      // Add attack message to combat log\n      addLogMessage(`You hit the ${currentEnemy.name} for ${playerDamage} damage!`);\n      \n      // Trigger animation\n      setCombatTick(prev => prev + 1);\n      \n      // Award combat XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        // Add XP to Attack and Strength\n        if (newState.player.skills[SKILL_IDS.ATTACK]) {\n          const attackXp = playerDamage * 4;\n          const currentAttackXp = newState.player.skills[SKILL_IDS.ATTACK].xp || 0;\n          newState.player.skills[SKILL_IDS.ATTACK].xp = currentAttackXp + attackXp;\n          \n          // Check for level ups\n          const attackLevel = newState.player.skills[SKILL_IDS.ATTACK].level;\n          const xpForNextLevel = calculateXpForNextLevel(attackLevel);\n          if (newState.player.skills[SKILL_IDS.ATTACK].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.ATTACK].level += 1;\n            addLogMessage(`Congratulations! Your Attack level is now ${newState.player.skills[SKILL_IDS.ATTACK].level}`);\n          }\n        }\n        \n        if (newState.player.skills[SKILL_IDS.STRENGTH]) {\n          const strengthXp = playerDamage * 4;\n          const currentStrengthXp = newState.player.skills[SKILL_IDS.STRENGTH].xp || 0;\n          newState.player.skills[SKILL_IDS.STRENGTH].xp = currentStrengthXp + strengthXp;\n          \n          // Check for level ups\n          const strengthLevel = newState.player.skills[SKILL_IDS.STRENGTH].level;\n          const xpForNextLevel = calculateXpForNextLevel(strengthLevel);\n          if (newState.player.skills[SKILL_IDS.STRENGTH].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.STRENGTH].level += 1;\n            addLogMessage(`Congratulations! Your Strength level is now ${newState.player.skills[SKILL_IDS.STRENGTH].level}`);\n          }\n        }\n        \n        return newState;\n      });\n      \n      // Check if enemy is defeated\n      if (newEnemyHealth <= 0) {\n        handleEnemyDefeated(currentEnemy);\n        return;\n      }\n    } else {\n      addLogMessage(`Your attack missed the ${currentEnemy.name}!`);\n      // Still trigger animation for the miss\n      setCombatTick(prev => prev + 1);\n    }\n    \n    // Schedule next player attack\n    setLastPlayerAttack(Date.now());\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handleEnemyDefeated]);\n  \n  /**\n   * Process enemy attack\n   */\n  const processEnemyAttack = useCallback(() => {\n    if (!currentEnemy || !gameState?.player) return;\n    \n    const stats = getPlayerStats();\n    \n    // Enemy attacks player\n    const enemyDamage = calculateDamage(currentEnemy.attack, currentEnemy.attack, stats.defense);\n    \n    if (enemyDamage > 0) {\n      addLogMessage(`The ${currentEnemy.name} hits you for ${enemyDamage} damage!`);\n      \n      // Trigger animation\n      setCombatTick(prev => prev + 2); // Use a different number to trigger a different animation\n      \n      // Update player health and award Defense XP\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        const newState = JSON.parse(JSON.stringify(prevState));\n        \n        // Add XP to Defense (positive XP for being hit)\n        if (newState.player.skills[SKILL_IDS.DEFENCE]) {\n          const defenseXp = enemyDamage * 4;\n          const currentDefenseXp = newState.player.skills[SKILL_IDS.DEFENCE].xp || 0;\n          newState.player.skills[SKILL_IDS.DEFENCE].xp = currentDefenseXp + defenseXp;\n          \n          // Check for level ups\n          const defenseLevel = newState.player.skills[SKILL_IDS.DEFENCE].level;\n          const xpForNextLevel = calculateXpForNextLevel(defenseLevel);\n          if (newState.player.skills[SKILL_IDS.DEFENCE].xp >= xpForNextLevel) {\n            newState.player.skills[SKILL_IDS.DEFENCE].level += 1;\n            addLogMessage(`Congratulations! Your Defense level is now ${newState.player.skills[SKILL_IDS.DEFENCE].level}`);\n          }\n        }\n        \n        // Reduce Hitpoints XP (as damage)\n        if (newState.player.skills[SKILL_IDS.HITPOINTS]) {\n          const currentHitpointsXp = newState.player.skills[SKILL_IDS.HITPOINTS].xp || 10;\n          newState.player.skills[SKILL_IDS.HITPOINTS].xp = Math.max(0, currentHitpointsXp - enemyDamage);\n          \n          // Check if player is defeated\n          if (newState.player.skills[SKILL_IDS.HITPOINTS].xp <= 0) {\n            handlePlayerDefeated();\n          }\n        }\n        \n        return newState;\n      });\n    } else {\n      addLogMessage(`The ${currentEnemy.name}'s attack missed you!`);\n      // Still trigger animation for the miss\n      setCombatTick(prev => prev + 2);\n    }\n    \n    // Schedule next enemy attack\n    setLastEnemyAttack(Date.now());\n  }, [currentEnemy, gameState, getPlayerStats, calculateDamage, addLogMessage, updateGameState, calculateXpForNextLevel, handlePlayerDefeated]);\n  \n  /**\n   * Process a single combat round - now manages the timing for both player and enemy attacks\n   */\n  const processCombatRound = useCallback(() => {\n    if (!currentEnemy || !gameState?.player) return;\n    \n    const now = Date.now();\n    const playerSpeed = getPlayerAttackSpeed();\n    const enemySpeed = currentEnemy.attackSpeed || 2000; // Default to 2 seconds if not specified\n    \n    // Check if it's time for player to attack\n    if (now - lastPlayerAttack >= playerSpeed) {\n      processPlayerAttack();\n    }\n    \n    // Check if it's time for enemy to attack\n    if (now - lastEnemyAttack >= enemySpeed) {\n      processEnemyAttack();\n    }\n  }, [currentEnemy, gameState, getPlayerAttackSpeed, lastPlayerAttack, lastEnemyAttack, processPlayerAttack, processEnemyAttack]);\n  \n  /**\n   * Start combat with an enemy\n   */\n  const startCombat = useCallback((enemyId: string) => {\n    // Stop any existing combat\n    if (combatInterval) {\n      clearInterval(combatInterval);\n      setCombatInterval(null);\n    }\n    \n    if (playerAttackTimer) {\n      clearTimeout(playerAttackTimer);\n      setPlayerAttackTimer(null);\n    }\n    \n    if (enemyAttackTimer) {\n      clearTimeout(enemyAttackTimer);\n      setEnemyAttackTimer(null);\n    }\n    \n    // Find the enemy\n    const enemy = enemies.find(e => e.id === enemyId);\n    if (!enemy) {\n      console.error(`Enemy with ID ${enemyId} not found`);\n      return;\n    }\n    \n    // Clone the enemy to avoid modifying the original\n    const enemyClone: Enemy = {\n      ...enemy,\n      health: enemy.maxHealth // Reset health\n    };\n    \n    setCurrentEnemy(enemyClone);\n    setCombatLog([`Combat started with ${enemyClone.name}!`]);\n    \n    // Reset attack timers\n    setLastPlayerAttack(Date.now());\n    setLastEnemyAttack(Date.now());\n    \n    // Update game state\n    updateGameState(prevState => {\n      if (!prevState) return prevState;\n      \n      return {\n        ...prevState,\n        player: {\n          ...prevState.player,\n          combat: {\n            currentEnemy: enemyClone,\n            isFighting: true\n          }\n        }\n      };\n    });\n    \n    // Start with player's first attack\n    processPlayerAttack();\n    \n    // Set up the enemy's first attack with appropriate delay\n    const enemyTimer = setTimeout(() => {\n      processEnemyAttack();\n    }, enemyClone.attackSpeed / 2); // Start at half the enemy's attack speed for better flow\n    \n    setEnemyAttackTimer(enemyTimer);\n    \n    // Start combat loop - check for attacks every 100ms\n    const interval = setInterval(processCombatRound, 100);\n    setCombatInterval(interval);\n    \n    return () => {\n      clearInterval(interval);\n      clearTimeout(enemyTimer);\n    };\n  }, [enemies, combatInterval, playerAttackTimer, enemyAttackTimer, updateGameState, processCombatRound, processPlayerAttack, processEnemyAttack]);\n  \n  /**\n   * Flee from combat\n   */\n  const fleeCombat = useCallback(() => {\n    if (!currentEnemy) return;\n    \n    // Higher defense gives better flee chance\n    const playerDefense = playerStats.defense;\n    const enemyAttack = currentEnemy.attack;\n    const baseFleeProbability = 0.5; // 50% base chance\n    \n    // Defense helps flee, enemy attack makes it harder\n    const fleeChance = Math.min(0.95, Math.max(0.3, baseFleeProbability + (playerDefense - enemyAttack) * 0.05));\n    \n    if (Math.random() <= fleeChance) {\n      addLogMessage('You successfully fled from combat!');\n      \n      // Stop combat loop\n      if (combatInterval) {\n        clearInterval(combatInterval);\n        setCombatInterval(null);\n      }\n      \n      // Stop attack timers\n      if (playerAttackTimer) {\n        clearTimeout(playerAttackTimer);\n        setPlayerAttackTimer(null);\n      }\n      \n      if (enemyAttackTimer) {\n        clearTimeout(enemyAttackTimer);\n        setEnemyAttackTimer(null);\n      }\n      \n      // Update player state\n      updateGameState(prevState => {\n        if (!prevState) return prevState;\n        \n        return {\n          ...prevState,\n          player: {\n            ...prevState.player,\n            combat: {\n              isFighting: false,\n              currentEnemy: undefined\n            }\n          }\n        };\n      });\n      \n      // Reset current enemy\n      setCurrentEnemy(null);\n    } else {\n      addLogMessage('You failed to flee!');\n      \n      // Enemy gets a free attack\n      processEnemyAttack();\n    }\n  }, [currentEnemy, playerStats, combatInterval, playerAttackTimer, enemyAttackTimer, addLogMessage, updateGameState, processEnemyAttack]);\n  \n  // Clean up interval and timers on unmount\n  useEffect(() => {\n    return () => {\n      if (combatInterval) {\n        clearInterval(combatInterval);\n      }\n      if (playerAttackTimer) {\n        clearTimeout(playerAttackTimer);\n      }\n      if (enemyAttackTimer) {\n        clearTimeout(enemyAttackTimer);\n      }\n    };\n  }, [combatInterval, playerAttackTimer, enemyAttackTimer]);\n  \n  return {\n    enemies,\n    currentEnemy,\n    isFighting: !!currentEnemy,\n    playerStats,\n    combatLog,\n    combatTick, // Expose combat tick for animations\n    startCombat,\n    fleeCombat,\n    processCombatRound // Exposed for manual combat if needed\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}