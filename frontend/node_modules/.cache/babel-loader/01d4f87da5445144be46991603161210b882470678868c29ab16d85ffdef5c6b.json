{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport { useSkills } from '../hooks/useSkills';\nimport { useGameContext } from '../context/GameContext';\n\n/**\r\n * Calculate the total XP needed to reach a specific level in OSRS\r\n */\nconst totalXpForLevel = level => {\n  let total = 0;\n  for (let i = 1; i < level; i++) {\n    total += calculateXpForNextLevel(i);\n  }\n  return total;\n};\n\n/**\r\n * Calculate the XP required for the next level based on OSRS formula\r\n */\nconst calculateXpForNextLevel = currentLevel => {\n  // OSRS formula: Each level requires points equal to Math.floor(level * 300 * 2^(level/7)) / 4\n  const MAX_LEVEL = 99;\n  if (currentLevel >= MAX_LEVEL) {\n    return Number.MAX_SAFE_INTEGER; // Effectively cap at level 99\n  }\n  return Math.floor(Math.pow(2, currentLevel / 7) * currentLevel * 300 / 4);\n};\n\n/**\r\n * GameTick component - Handles game updates at regular intervals\r\n * This component doesn't render anything but creates a game loop\r\n */\nconst GameTick = () => {\n  _s();\n  const {\n    getActiveSkills,\n    addExperience,\n    addMasteryExperience\n  } = useSkills();\n  const {\n    gameState,\n    updateGameState\n  } = useGameContext();\n  const lastUpdateRef = useRef(Date.now());\n  const initializedRef = useRef(false);\n\n  // Initialize totalXp for existing skills (for older saves)\n  useEffect(() => {\n    if (gameState && !initializedRef.current) {\n      initializedRef.current = true;\n\n      // Check if any skills don't have totalXp and initialize them\n      const needsUpdate = Object.values(gameState.player.skills).some(skill => skill.totalXp === undefined);\n      if (needsUpdate) {\n        console.log('Initializing totalXp for older saves');\n        updateGameState(prevState => {\n          if (!prevState) return null;\n          const newState = JSON.parse(JSON.stringify(prevState));\n\n          // Use proper type for skill and ensure all skills have totalXp\n          Object.values(newState.player.skills).forEach(skill => {\n            if (skill.totalXp === undefined) {\n              // Calculate totalXp based on current level and xp\n              const levelBaseXp = totalXpForLevel(skill.level);\n              skill.totalXp = levelBaseXp + (skill.xp || 0);\n\n              // Ensure xp is initialized if missing\n              if (skill.xp === undefined) {\n                skill.xp = 0;\n              }\n\n              // Ensure xpPerAction is initialized if missing\n              if (skill.xpPerAction === undefined) {\n                skill.xpPerAction = 5; // Default value\n                console.warn(`Missing xpPerAction for skill ${skill.name}, initializing to ${skill.xpPerAction}`);\n              }\n            }\n          });\n          return newState;\n        });\n      }\n    }\n  }, [gameState, updateGameState]);\n\n  // Set up game tick for recurring actions\n  useEffect(() => {\n    if (!gameState) return; // Don't set up game tick if no gameState\n\n    console.log('GameTick initialized');\n    const tickInterval = 1000; // Update every second\n\n    const gameLoop = () => {\n      const now = Date.now();\n      const deltaTime = now - lastUpdateRef.current;\n      lastUpdateRef.current = now;\n\n      // Get all active skills\n      const activeSkills = getActiveSkills();\n      if (activeSkills.length > 0) {\n        console.log('Active skills:', activeSkills);\n      }\n\n      // Update each active skill\n      activeSkills.forEach(skillId => {\n        var _gameState$player, _gameState$player$ski;\n        const skill = gameState === null || gameState === void 0 ? void 0 : (_gameState$player = gameState.player) === null || _gameState$player === void 0 ? void 0 : (_gameState$player$ski = _gameState$player.skills) === null || _gameState$player$ski === void 0 ? void 0 : _gameState$player$ski[skillId];\n        if (skill) {\n          // Ensure skill has required properties\n          if (typeof skill.xpPerAction !== 'number' || isNaN(skill.xpPerAction)) {\n            console.error(`Skill ${skillId} has invalid xpPerAction: ${skill.xpPerAction}`);\n            return;\n          }\n\n          // Calculate XP gain based on skill's xpPerAction and time elapsed\n          // Increased XP gain for more noticeable progression (25x faster for testing)\n          const xpGain = skill.xpPerAction * (deltaTime / 1000) * 25;\n          console.log(`Adding ${xpGain} XP to ${skill.name} (xpPerAction: ${skill.xpPerAction})`);\n\n          // Add XP to the skill (ensure it's a positive number)\n          addExperience(skillId, Math.max(0, xpGain));\n\n          // If the skill has mastery, add mastery experience as well\n          if (skill.mastery) {\n            // Mastery XP is typically a fraction of regular XP\n            const masteryXpGain = xpGain * 0.5;\n            addMasteryExperience(skillId, masteryXpGain);\n          }\n        } else {\n          console.error(`Skill ${skillId} is active but not found in gameState`);\n        }\n      });\n    };\n\n    // Start the game loop\n    const timer = setInterval(gameLoop, tickInterval);\n    console.log('Game loop started with interval:', tickInterval);\n\n    // Clean up on unmount\n    return () => {\n      console.log('GameTick component unmounted, clearing interval');\n      clearInterval(timer);\n    };\n  }, [gameState, getActiveSkills, addExperience, addMasteryExperience]);\n\n  // This component doesn't render anything\n  return null;\n};\n_s(GameTick, \"xvJo05FxqMHqszDb86B87blClNM=\", false, function () {\n  return [useSkills, useGameContext];\n});\n_c = GameTick;\nexport default GameTick;\nvar _c;\n$RefreshReg$(_c, \"GameTick\");","map":{"version":3,"names":["useEffect","useRef","useSkills","useGameContext","totalXpForLevel","level","total","i","calculateXpForNextLevel","currentLevel","MAX_LEVEL","Number","MAX_SAFE_INTEGER","Math","floor","pow","GameTick","_s","getActiveSkills","addExperience","addMasteryExperience","gameState","updateGameState","lastUpdateRef","Date","now","initializedRef","current","needsUpdate","Object","values","player","skills","some","skill","totalXp","undefined","console","log","prevState","newState","JSON","parse","stringify","forEach","levelBaseXp","xp","xpPerAction","warn","name","tickInterval","gameLoop","deltaTime","activeSkills","length","skillId","_gameState$player","_gameState$player$ski","isNaN","error","xpGain","max","mastery","masteryXpGain","timer","setInterval","clearInterval","_c","$RefreshReg$"],"sources":["C:/Users/Domin/OneDrive/Desktop/coding/WaveringTides/frontend/src/components/GameTick.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\nimport { useSkills } from '../hooks/useSkills';\r\nimport { useGameContext } from '../context/GameContext';\r\n\r\n/**\r\n * Calculate the total XP needed to reach a specific level in OSRS\r\n */\r\nconst totalXpForLevel = (level: number): number => {\r\n  let total = 0;\r\n  for (let i = 1; i < level; i++) {\r\n    total += calculateXpForNextLevel(i);\r\n  }\r\n  return total;\r\n};\r\n\r\n/**\r\n * Calculate the XP required for the next level based on OSRS formula\r\n */\r\nconst calculateXpForNextLevel = (currentLevel: number): number => {\r\n  // OSRS formula: Each level requires points equal to Math.floor(level * 300 * 2^(level/7)) / 4\r\n  const MAX_LEVEL = 99;\r\n  \r\n  if (currentLevel >= MAX_LEVEL) {\r\n    return Number.MAX_SAFE_INTEGER; // Effectively cap at level 99\r\n  }\r\n  \r\n  return Math.floor((Math.pow(2, (currentLevel) / 7) * currentLevel * 300) / 4);\r\n};\r\n\r\n/**\r\n * GameTick component - Handles game updates at regular intervals\r\n * This component doesn't render anything but creates a game loop\r\n */\r\nconst GameTick: React.FC = () => {\r\n  const { getActiveSkills, addExperience, addMasteryExperience } = useSkills();\r\n  const { gameState, updateGameState } = useGameContext();\r\n  const lastUpdateRef = useRef<number>(Date.now());\r\n  const initializedRef = useRef<boolean>(false);\r\n  \r\n  // Initialize totalXp for existing skills (for older saves)\r\n  useEffect(() => {\r\n    if (gameState && !initializedRef.current) {\r\n      initializedRef.current = true;\r\n      \r\n      // Check if any skills don't have totalXp and initialize them\r\n      const needsUpdate = Object.values(gameState.player.skills).some(\r\n        (skill: any) => skill.totalXp === undefined\r\n      );\r\n      \r\n      if (needsUpdate) {\r\n        console.log('Initializing totalXp for older saves');\r\n        updateGameState((prevState) => {\r\n          if (!prevState) return null;\r\n          \r\n          const newState = JSON.parse(JSON.stringify(prevState));\r\n          \r\n          // Use proper type for skill and ensure all skills have totalXp\r\n          Object.values(newState.player.skills).forEach((skill: any) => {\r\n            if (skill.totalXp === undefined) {\r\n              // Calculate totalXp based on current level and xp\r\n              const levelBaseXp = totalXpForLevel(skill.level);\r\n              skill.totalXp = levelBaseXp + (skill.xp || 0);\r\n              \r\n              // Ensure xp is initialized if missing\r\n              if (skill.xp === undefined) {\r\n                skill.xp = 0;\r\n              }\r\n              \r\n              // Ensure xpPerAction is initialized if missing\r\n              if (skill.xpPerAction === undefined) {\r\n                skill.xpPerAction = 5; // Default value\r\n                console.warn(`Missing xpPerAction for skill ${skill.name}, initializing to ${skill.xpPerAction}`);\r\n              }\r\n            }\r\n          });\r\n          \r\n          return newState;\r\n        });\r\n      }\r\n    }\r\n  }, [gameState, updateGameState]);\r\n  \r\n  // Set up game tick for recurring actions\r\n  useEffect(() => {\r\n    if (!gameState) return; // Don't set up game tick if no gameState\r\n    \r\n    console.log('GameTick initialized');\r\n    \r\n    const tickInterval = 1000; // Update every second\r\n    \r\n    const gameLoop = () => {\r\n      const now = Date.now();\r\n      const deltaTime = now - lastUpdateRef.current;\r\n      lastUpdateRef.current = now;\r\n      \r\n      // Get all active skills\r\n      const activeSkills = getActiveSkills();\r\n      \r\n      if (activeSkills.length > 0) {\r\n        console.log('Active skills:', activeSkills);\r\n      }\r\n      \r\n      // Update each active skill\r\n      activeSkills.forEach(skillId => {\r\n        const skill = gameState?.player?.skills?.[skillId];\r\n        if (skill) {\r\n          // Ensure skill has required properties\r\n          if (typeof skill.xpPerAction !== 'number' || isNaN(skill.xpPerAction)) {\r\n            console.error(`Skill ${skillId} has invalid xpPerAction: ${skill.xpPerAction}`);\r\n            return;\r\n          }\r\n          \r\n          // Calculate XP gain based on skill's xpPerAction and time elapsed\r\n          // Increased XP gain for more noticeable progression (25x faster for testing)\r\n          const xpGain = skill.xpPerAction * (deltaTime / 1000) * 25;\r\n          \r\n          console.log(`Adding ${xpGain} XP to ${skill.name} (xpPerAction: ${skill.xpPerAction})`);\r\n          \r\n          // Add XP to the skill (ensure it's a positive number)\r\n          addExperience(skillId, Math.max(0, xpGain));\r\n          \r\n          // If the skill has mastery, add mastery experience as well\r\n          if (skill.mastery) {\r\n            // Mastery XP is typically a fraction of regular XP\r\n            const masteryXpGain = xpGain * 0.5;\r\n            addMasteryExperience(skillId, masteryXpGain);\r\n          }\r\n        } else {\r\n          console.error(`Skill ${skillId} is active but not found in gameState`);\r\n        }\r\n      });\r\n    };\r\n    \r\n    // Start the game loop\r\n    const timer = setInterval(gameLoop, tickInterval);\r\n    console.log('Game loop started with interval:', tickInterval);\r\n    \r\n    // Clean up on unmount\r\n    return () => {\r\n      console.log('GameTick component unmounted, clearing interval');\r\n      clearInterval(timer);\r\n    };\r\n  }, [gameState, getActiveSkills, addExperience, addMasteryExperience]);\r\n  \r\n  // This component doesn't render anything\r\n  return null;\r\n};\r\n\r\nexport default GameTick; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}